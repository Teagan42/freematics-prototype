<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freematics BLE Dashboard</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #212529;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e9ecef;
            }
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        @media (prefers-color-scheme: dark) {
            .header {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .connect-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .connect-btn:hover {
            background: #0056b3;
        }
        .connect-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        .status-indicator.connected {
            background: #28a745;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        @media (prefers-color-scheme: dark) {
            .metric-card {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
            transition: color 0.3s ease;
        }
        .metric-value.normal { color: #28a745; }
        .metric-value.warning { color: #ffc107; }
        .metric-value.danger { color: #dc3545; }
        .metric-value.info { color: #007bff; }
        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .chart-container {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .gps-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        @media (prefers-color-scheme: dark) {
            .gps-container {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .gps-coords {
            font-family: monospace;
            font-size: 1.1em;
            color: #495057;
            margin: 10px 0;
        }
        .data-log {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .data-log {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .log-entry {
            font-family: monospace;
            font-size: 0.9em;
            padding: 8px;
            border-bottom: 1px solid #eee;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
            border-radius: 4px;
            margin: 2px 0;
            line-height: 1.4;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        
        @media (prefers-color-scheme: dark) {
            .log-entry {
                border-bottom: 1px solid #495057;
            }
        }
        .log-entry.error {
            color: #dc3545;
            background-color: #f8d7da;
        }
        .log-entry.status {
            color: #0c5460;
            background-color: #d1ecf1;
        }
        .log-entry.heartbeat {
            color: #155724;
            background-color: #d4edda;
        }
        .log-entry.connect {
            color: #004085;
            background-color: #cce5ff;
            font-weight: bold;
        }
        .log-entry.disconnect {
            color: #721c24;
            background-color: #f5c6cb;
            font-weight: bold;
        }
        .log-entry.tx {
            color: #856404;
            background-color: #fff3cd;
            font-style: italic;
        }
        .log-entry.system {
            color: #6c757d;
            background-color: #f8f9fa;
        }
        .status-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .status-panel {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .status-item {
            display: inline-block;
            margin: 5px 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        .status-item.real { background: #d4edda; color: #155724; }
        .status-item.simulated { background: #fff3cd; color: #856404; }
        .status-item.disabled { background: #e2e3e5; color: #6c757d; }
        .status-item.ok { background: #d4edda; color: #155724; }
        .status-item.fail { background: #f8d7da; color: #721c24; }
        .status-item.off { background: #e2e3e5; color: #6c757d; }
        .sim-control-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        .sim-control-btn:hover {
            background: #138496;
        }
        .sim-control-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .sim-control-btn.stop {
            background: #dc3545;
        }
        .sim-control-btn.stop:hover {
            background: #c82333;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .tabs {
            display: flex;
            background: white;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 0;
            overflow-x: auto;
        }
        
        @media (prefers-color-scheme: dark) {
            .tabs {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .tab {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .tab:hover {
            background: #f8f9fa;
        }
        .tab.active {
            border-bottom-color: #007bff;
            background: #f8f9fa;
            color: #007bff;
        }
        .tab-content {
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .tab-content {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        .compact-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .compact-metric {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        
        @media (prefers-color-scheme: dark) {
            .compact-metric {
                background: #3a3a3a;
                border: 1px solid #495057;
            }
        }
        .compact-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        .compact-label {
            color: #6c757d;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        @media (max-width: 768px) {
            .dashboard {
                padding: 10px;
            }
            .header {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .metric-card {
                padding: 15px 10px;
            }
            .metric-value {
                font-size: 2em;
            }
            .tab {
                padding: 12px 15px;
                font-size: 0.9em;
            }
            .tab-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function FreematicsDashboard() {
            const [isConnected, setIsConnected] = useState(false);
            const [device, setDevice] = useState(null);
            const [characteristic, setCharacteristic] = useState(null);
            const [error, setError] = useState(null);
            const [apiVersionError, setApiVersionError] = useState(null);
            const [data, setData] = useState({
                rpm: 0,
                speed: 0,
                coolant: 0,
                enginePressure: 0,
                batteryVoltage: 0,
                ambientTemp: 0,
                gps: { lat: 0, lng: 0, satellites: 0 },
                timestamp: 0,
                dataMode: 'DISABLED',
                lastError: '',
                systemStatus: {},
                simulationRunning: false,
                apiVersion: null,
                // Additional engine parameters
                engineLoad: 0,
                throttlePos: 0,
                intakeTemp: 0,
                oilTemp: 0,
                exhaustTemp: 0,
                fuelPressure: 0,
                fuelLevel: 0,
                fuelTrimShort: 0,
                fuelTrimLong: 0,
                fuelRate: 0,
                mafFlow: 0,
                o2Voltage: 0,
                catalystTemp: 0,
                boostPressure: 0,
                turboRpm: 0
            });
            
            // Client-side simulation state
            const [clientSimulation, setClientSimulation] = useState({
                enabled: false,
                startTime: null,
                interval: null
            });
            
            const [diagnosticResults, setDiagnosticResults] = useState('');
            const [diagnosticRunning, setDiagnosticRunning] = useState(false);
            const [diagnosticError, setDiagnosticError] = useState(null);
            const [dataParseErrors, setDataParseErrors] = useState([]);
            
            // Expected API version - update this when making breaking changes
            const EXPECTED_API_VERSION = 1;
            const [dataHistory, setDataHistory] = useState([]);
            const [rawDataLog, setRawDataLog] = useState([]);

            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const tempChartRef = useRef(null);
            const tempChartInstance = useRef(null);
            const percentChartRef = useRef(null);
            const percentChartInstance = useRef(null);
            const fuelChartRef = useRef(null);
            const fuelChartInstance = useRef(null);
            const [activeTab, setActiveTab] = useState('overview');

            // Initialize charts
            useEffect(() => {
                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                const textColor = isDarkMode ? '#e9ecef' : '#666';
                const gridColor = isDarkMode ? '#495057' : '#e0e0e0';

                // Main Performance Chart
                if (chartRef.current && !chartInstance.current) {
                    const ctx = chartRef.current.getContext('2d');
                    chartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'RPM',
                                    data: [],
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Speed (mph)',
                                    data: [],
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: { display: true, text: 'Time (seconds)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    title: { display: true, text: 'RPM', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    title: { display: true, text: 'Speed (mph)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { drawOnChartArea: false, color: gridColor }
                                }
                            },
                            plugins: {
                                title: { display: true, text: 'Engine Performance', color: textColor },
                                legend: { labels: { color: textColor } }
                            }
                        }
                    });
                }

                // Temperature Chart
                if (tempChartRef.current && !tempChartInstance.current) {
                    const ctx = tempChartRef.current.getContext('2d');
                    tempChartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Coolant Temp (°F)',
                                    data: [],
                                    borderColor: '#dc3545',
                                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Intake Temp (°F)',
                                    data: [],
                                    borderColor: '#17a2b8',
                                    backgroundColor: 'rgba(23, 162, 184, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Oil Temp (°F)',
                                    data: [],
                                    borderColor: '#fd7e14',
                                    backgroundColor: 'rgba(253, 126, 20, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Exhaust Temp (°F)',
                                    data: [],
                                    borderColor: '#6f42c1',
                                    backgroundColor: 'rgba(111, 66, 193, 0.1)',
                                    yAxisID: 'y'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: { display: true, text: 'Time (seconds)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    title: { display: true, text: 'Temperature (°F)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                }
                            },
                            plugins: {
                                title: { display: true, text: 'Temperature Monitoring', color: textColor },
                                legend: { labels: { color: textColor } }
                            }
                        }
                    });
                }

                // Percentage Chart
                if (percentChartRef.current && !percentChartInstance.current) {
                    const ctx = percentChartRef.current.getContext('2d');
                    percentChartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Engine Load (%)',
                                    data: [],
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Throttle Position (%)',
                                    data: [],
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Fuel Level (%)',
                                    data: [],
                                    borderColor: '#ffc107',
                                    backgroundColor: 'rgba(255, 193, 7, 0.1)',
                                    yAxisID: 'y'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: { display: true, text: 'Time (seconds)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    min: 0,
                                    max: 100,
                                    title: { display: true, text: 'Percentage (%)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                }
                            },
                            plugins: {
                                title: { display: true, text: 'System Load & Levels', color: textColor },
                                legend: { labels: { color: textColor } }
                            }
                        }
                    });
                }

                // Fuel System Chart
                if (fuelChartRef.current && !fuelChartInstance.current) {
                    const ctx = fuelChartRef.current.getContext('2d');
                    fuelChartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Fuel Pressure (psi)',
                                    data: [],
                                    borderColor: '#dc3545',
                                    backgroundColor: 'rgba(220, 53, 69, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Fuel Rate (L/h)',
                                    data: [],
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    yAxisID: 'y1'
                                },
                                {
                                    label: 'Short Term Trim (%)',
                                    data: [],
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    yAxisID: 'y2'
                                },
                                {
                                    label: 'Long Term Trim (%)',
                                    data: [],
                                    borderColor: '#6f42c1',
                                    backgroundColor: 'rgba(111, 66, 193, 0.1)',
                                    yAxisID: 'y2'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: { display: true, text: 'Time (seconds)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    title: { display: true, text: 'Pressure (psi)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { color: gridColor }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    title: { display: true, text: 'Flow Rate (L/h)', color: textColor },
                                    ticks: { color: textColor },
                                    grid: { drawOnChartArea: false, color: gridColor }
                                },
                                y2: {
                                    type: 'linear',
                                    display: false,
                                    min: -25,
                                    max: 25,
                                    title: { display: true, text: 'Trim (%)', color: textColor }
                                }
                            },
                            plugins: {
                                title: { display: true, text: 'Fuel System Analysis', color: textColor },
                                legend: { labels: { color: textColor } }
                            }
                        }
                    });
                }
            }, []);

            // Update charts when data changes
            useEffect(() => {
                if (dataHistory.length > 0) {
                    const startTime = dataHistory[0].timestamp;
                    const timeLabels = dataHistory.map(d => ((d.timestamp - startTime) / 1000).toFixed(1));

                    // Update main performance chart
                    if (chartInstance.current) {
                        const chart = chartInstance.current;
                        chart.data.labels = timeLabels;
                        chart.data.datasets[0].data = dataHistory.map(d => d.rpm || 0);
                        chart.data.datasets[1].data = dataHistory.map(d => d.speed || 0);

                        if (chart.data.labels.length > 50) {
                            chart.data.labels = chart.data.labels.slice(-50);
                            chart.data.datasets[0].data = chart.data.datasets[0].data.slice(-50);
                            chart.data.datasets[1].data = chart.data.datasets[1].data.slice(-50);
                        }
                        chart.update('none');
                    }

                    // Update temperature chart
                    if (tempChartInstance.current) {
                        const chart = tempChartInstance.current;
                        chart.data.labels = timeLabels;
                        chart.data.datasets[0].data = dataHistory.map(d => d.coolant || 0);
                        chart.data.datasets[1].data = dataHistory.map(d => d.intakeTemp || 0);
                        chart.data.datasets[2].data = dataHistory.map(d => d.oilTemp || 0);
                        chart.data.datasets[3].data = dataHistory.map(d => d.exhaustTemp || 0);

                        if (chart.data.labels.length > 50) {
                            chart.data.labels = chart.data.labels.slice(-50);
                            chart.data.datasets.forEach(dataset => {
                                dataset.data = dataset.data.slice(-50);
                            });
                        }
                        chart.update('none');
                    }

                    // Update percentage chart
                    if (percentChartInstance.current) {
                        const chart = percentChartInstance.current;
                        chart.data.labels = timeLabels;
                        chart.data.datasets[0].data = dataHistory.map(d => d.engineLoad || 0);
                        chart.data.datasets[1].data = dataHistory.map(d => d.throttlePos || 0);
                        chart.data.datasets[2].data = dataHistory.map(d => d.fuelLevel || 0);

                        if (chart.data.labels.length > 50) {
                            chart.data.labels = chart.data.labels.slice(-50);
                            chart.data.datasets.forEach(dataset => {
                                dataset.data = dataset.data.slice(-50);
                            });
                        }
                        chart.update('none');
                    }

                    // Update fuel chart
                    if (fuelChartInstance.current) {
                        const chart = fuelChartInstance.current;
                        chart.data.labels = timeLabels;
                        chart.data.datasets[0].data = dataHistory.map(d => d.fuelPressure || 0);
                        chart.data.datasets[1].data = dataHistory.map(d => d.fuelRate || 0);
                        chart.data.datasets[2].data = dataHistory.map(d => d.fuelTrimShort || 0);
                        chart.data.datasets[3].data = dataHistory.map(d => d.fuelTrimLong || 0);

                        if (chart.data.labels.length > 50) {
                            chart.data.labels = chart.data.labels.slice(-50);
                            chart.data.datasets.forEach(dataset => {
                                dataset.data = dataset.data.slice(-50);
                            });
                        }
                        chart.update('none');
                    }
                }
            }, [dataHistory]);

            const connectToDevice = async () => {
                try {
                    setError(null);

                    if (!navigator.bluetooth) {
                        throw new Error('Web Bluetooth is not supported in this browser. Please use Chrome/Edge with HTTPS.');
                    }

                    // Check if we're on HTTPS (required for Web Bluetooth)
                    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                        throw new Error('Web Bluetooth requires HTTPS. Please serve this page over HTTPS.');
                    }

                    console.log('Requesting Bluetooth device...');
                    
                    // Add connection event to log
                    setRawDataLog(prev => [...prev, {
                        timestamp: new Date().toLocaleTimeString(),
                        data: 'Initiating Bluetooth connection...',
                        type: 'system'
                    }]);
                    const device = await navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: [
                            '12345678-1234-1234-1234-123456789abc',
                            '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                            '0000180a-0000-1000-8000-00805f9b34fb'  // Device Information Service
                        ]
                    }).catch(err => {
                        if (err.name === 'NotFoundError') {
                            throw new Error('No Bluetooth device found. Make sure the device is powered on and in range.');
                        }
                        throw err;
                    });

                    console.log('Connecting to GATT server...');
                    console.log('Device name:', device.name);
                    console.log('Device ID:', device.id);
                    
                    const server = await device.gatt.connect();


                    console.log('Getting service...');
                    let service;
                    try {
                        service = await server.getPrimaryService('12345678-1234-1234-1234-123456789abc');
                    } catch (serviceErr) {
                        console.error('Service not found, trying to discover available services...');
                        
                        // Try to get all available services for debugging
                        try {
                            const services = await server.getPrimaryServices();
                            console.log('Available services:', services.map(s => s.uuid));
                            
                            // Try common service UUIDs
                            const commonServices = [
                                '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                                '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                                '6e400001-b5a3-f393-e0a9-e50e24dcca9e'  // Nordic UART Service
                            ];
                            
                            for (const serviceUuid of commonServices) {
                                try {
                                    service = await server.getPrimaryService(serviceUuid);
                                    console.log('Using service:', serviceUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!service && services.length > 0) {
                                // Use the first available service
                                service = services[0];
                                console.log('Using first available service:', service.uuid);
                            }
                        } catch (discoveryErr) {
                            console.error('Service discovery failed:', discoveryErr);
                        }
                        
                        if (!service) {
                            throw new Error('No compatible service found. Make sure the device is a Freematics device with BLE enabled.');
                        }
                    }

                    console.log('Getting characteristic...');
                    let characteristic;
                    try {
                        characteristic = await service.getCharacteristic('12345678-1234-1234-1234-123456789abc');
                    } catch (charErr) {
                        console.error('Characteristic not found, trying to discover available characteristics...');
                        
                        try {
                            const characteristics = await service.getCharacteristics();
                            console.log('Available characteristics:', characteristics.map(c => c.uuid));
                            
                            // Try common characteristic UUIDs
                            const commonCharacteristics = [
                                '6e400002-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART TX
                                '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART RX
                                '00002a19-0000-1000-8000-00805f9b34fb'  // Battery Level
                            ];
                            
                            for (const charUuid of commonCharacteristics) {
                                try {
                                    characteristic = await service.getCharacteristic(charUuid);
                                    console.log('Using characteristic:', charUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!characteristic && characteristics.length > 0) {
                                // Use the first available characteristic that supports notifications
                                for (const char of characteristics) {
                                    if (char.properties.notify || char.properties.read) {
                                        characteristic = char;
                                        console.log('Using first compatible characteristic:', char.uuid);
                                        break;
                                    }
                                }
                            }
                        } catch (discoveryErr) {
                            console.error('Characteristic discovery failed:', discoveryErr);
                        }
                        
                        if (!characteristic) {
                            throw new Error('No compatible characteristic found. Device may not support the expected BLE protocol.');
                        }
                    }

                    // Start notifications if supported
                    if (characteristic.properties.notify) {
                        await characteristic.startNotifications();
                        characteristic.addEventListener('characteristicvaluechanged', handleDataReceived);
                        console.log('Notifications started successfully');
                        
                        // Send initial ping to device
                        setTimeout(() => {
                            if (characteristic && device.gatt.connected) {
                                const pingMessage = 'CMD:PING';
                                characteristic.writeValue(new TextEncoder().encode(pingMessage));
                                console.log('Sent ping to device:', pingMessage);
                                
                                setRawDataLog(prev => [...prev, {
                                    timestamp: new Date().toLocaleTimeString(),
                                    data: 'TX: ' + pingMessage,
                                    type: 'tx'
                                }]);
                            }
                        }, 1000);
                        
                    } else if (characteristic.properties.read) {
                        console.log('Device supports read but not notifications, will poll for data');
                        // Set up polling for read-only characteristics
                        const pollData = async () => {
                            try {
                                const value = await characteristic.readValue();
                                handleDataReceived({ target: { value } });
                            } catch (readErr) {
                                console.error('Read error:', readErr);
                            }
                        };
                        setInterval(pollData, 1000); // Poll every second
                    } else {
                        console.warn('Characteristic does not support notifications or reading');
                    }

                    setDevice(device);
                    setCharacteristic(characteristic);
                    setIsConnected(true);

                    device.addEventListener('gattserverdisconnected', handleDisconnection);
                    
                    // Log successful connection
                    setRawDataLog(prev => [...prev, {
                        timestamp: new Date().toLocaleTimeString(),
                        data: `Connected to ${device.name || 'Unknown Device'}`,
                        type: 'connect'
                    }]);

                } catch (err) {
                    console.error('Connection failed:', err);
                    setError(`Connection failed: ${err.message}`);
                }
            };

            const validateApiVersion = (receivedVersion) => {
                if (receivedVersion === null || receivedVersion === undefined) {
                    setApiVersionError({
                        type: 'missing',
                        message: 'Device firmware does not report API version. Please update the firmware.'
                    });
                    return false;
                } else if (receivedVersion > EXPECTED_API_VERSION) {
                    setApiVersionError({
                        type: 'newer',
                        message: `Device firmware API version (${receivedVersion}) is newer than dashboard expects (${EXPECTED_API_VERSION}). Please update the dashboard.`
                    });
                    return false;
                } else if (receivedVersion < EXPECTED_API_VERSION) {
                    setApiVersionError({
                        type: 'older',
                        message: `Device firmware API version (${receivedVersion}) is older than dashboard expects (${EXPECTED_API_VERSION}). Please deploy updated firmware.`
                    });
                    return false;
                } else {
                    setApiVersionError(null);
                    return true;
                }
            };

            const handleDataReceived = (event) => {
                try {
                    const value = event.target.value;
                    const decoder = new TextDecoder();
                    const rawData = decoder.decode(value);

                    console.log('BLE RX:', rawData);
                    
                    // Clear any previous parse errors on successful decode
                    setDataParseErrors(prev => prev.filter(err => err.type !== 'decode'));

                // Add to raw data log with message type detection
                const logEntry = {
                    timestamp: new Date().toLocaleTimeString(),
                    data: rawData,
                    type: 'data'
                };

                // Detect message types for better logging
                if (rawData.includes('ERROR:')) {
                    logEntry.type = 'error';
                } else if (rawData.includes('STATUS:')) {
                    logEntry.type = 'status';
                } else if (rawData.includes('HEARTBEAT:')) {
                    logEntry.type = 'heartbeat';
                } else if (rawData.includes('CONNECT:')) {
                    logEntry.type = 'connect';
                } else if (rawData.includes('PONG:')) {
                    logEntry.type = 'pong';
                }

                setRawDataLog(prev => [...prev.slice(-50), logEntry]);

                // Handle simple status/heartbeat messages that don't contain sensor data
                if (rawData.startsWith('HEARTBEAT:') || rawData.startsWith('PONG:') || rawData.startsWith('ERROR:')) {
                    // These messages don't contain sensor data, so don't update the main data state
                    // Just handle any specific status updates they might contain
                    if (rawData.includes('MODE:')) {
                        const modeMatch = rawData.match(/MODE:(\w+)/);
                        if (modeMatch) {
                            const mode = modeMatch[1];
                            setData(prev => ({
                                ...prev,
                                dataMode: mode,
                                simulationRunning: (mode === 'SIMULATED')
                            }));
                        }
                    }
                    return; // Don't process as sensor data
                }

                // Parse the data format: messageId:timestamp,RPM:value;SPD:value;GPS:lat,lng;
                try {
                    // Validate raw data format before processing
                    if (!rawData || typeof rawData !== 'string' || rawData.trim().length === 0) {
                        throw new Error('Empty or invalid data received');
                    }
                    // Handle message counter prefix (messageId:data)
                    let dataToProcess = rawData;
                    let messageId = null;
                    
                    if (rawData.includes(':') && rawData.match(/^\d+:/)) {
                        const colonIndex = rawData.indexOf(':');
                        messageId = parseInt(rawData.substring(0, colonIndex));
                        dataToProcess = rawData.substring(colonIndex + 1);
                        console.log('Message ID:', messageId, 'Data:', dataToProcess);
                    }
                    
                    const parts = dataToProcess.split(',');
                    if (parts.length >= 2) {
                        const timestamp = parseInt(parts[0]);
                        const dataString = parts.slice(1).join(',');

                        // Only create updates object for fields that are actually present
                        const dataUpdates = { timestamp };
                        let hasSensorData = false;

                        // Parse key-value pairs
                        const pairs = dataString.split(';').filter(p => p.length > 0);

                        pairs.forEach(pair => {
                            if (pair.includes(':')) {
                                const [key, value] = pair.split(':');

                                switch (key) {
                                    case 'RPM':
                                        dataUpdates.rpm = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'SPD':
                                        // Convert km/h to mph
                                        dataUpdates.speed = Math.round((parseInt(value) || 0) * 0.621371);
                                        hasSensorData = true;
                                        break;
                                    case 'COOLANT':
                                        // Convert Celsius to Fahrenheit
                                        dataUpdates.coolant = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'PRESSURE':
                                        dataUpdates.enginePressure = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'BATTERY':
                                        dataUpdates.batteryVoltage = (parseInt(value) || 0) / 100; // Assuming value is in centivolt
                                        hasSensorData = true;
                                        break;
                                    case 'AMBIENT':
                                        // Convert Celsius to Fahrenheit
                                        dataUpdates.ambientTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'ENGINE_LOAD':
                                        dataUpdates.engineLoad = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'THROTTLE_POS':
                                        dataUpdates.throttlePos = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'INTAKE_TEMP':
                                        dataUpdates.intakeTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'OIL_TEMP':
                                        dataUpdates.oilTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'EXHAUST_TEMP':
                                        dataUpdates.exhaustTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'FUEL_PRESSURE':
                                        dataUpdates.fuelPressure = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'FUEL_LEVEL':
                                        dataUpdates.fuelLevel = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'FUEL_TRIM_SHORT':
                                        dataUpdates.fuelTrimShort = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'FUEL_TRIM_LONG':
                                        dataUpdates.fuelTrimLong = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'FUEL_RATE':
                                        dataUpdates.fuelRate = (parseInt(value) || 0) / 100; // Convert from cL/h to L/h
                                        hasSensorData = true;
                                        break;
                                    case 'MAF_FLOW':
                                        dataUpdates.mafFlow = (parseInt(value) || 0) / 100; // Convert from cg/s to g/s
                                        hasSensorData = true;
                                        break;
                                    case 'O2_VOLTAGE':
                                        dataUpdates.o2Voltage = (parseInt(value) || 0) / 1000; // Convert from mV to V
                                        hasSensorData = true;
                                        break;
                                    case 'CATALYST_TEMP':
                                        dataUpdates.catalystTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'BOOST_PRESSURE':
                                        dataUpdates.boostPressure = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'TURBO_RPM':
                                        dataUpdates.turboRpm = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'GPS':
                                        const coords = value.split(',');
                                        if (coords.length >= 2) {
                                            dataUpdates.gps = {
                                                lat: parseFloat(coords[0]) || 0,
                                                lng: parseFloat(coords[1]) || 0
                                            };
                                        }
                                        hasSensorData = true;
                                        break;
                                    case 'SAT':
                                        // Parse satellite count and indicator
                                        const satMatch = value.match(/^(\d+)(\([^)]+\))?/);
                                        if (satMatch) {
                                            dataUpdates.gps = {
                                                ...(dataUpdates.gps || {}),
                                                satellites: parseInt(satMatch[1]) || 0,
                                                satelliteIndicator: satMatch[2] || null
                                            };
                                        } else {
                                            dataUpdates.gps = {
                                                ...(dataUpdates.gps || {}),
                                                satellites: parseInt(value) || 0,
                                                satelliteIndicator: null
                                            };
                                        }
                                        break;
                                    case 'MODE':
                                        dataUpdates.dataMode = value;
                                        // Don't update simulationRunning from device - it's client-side now
                                        break;
                                    case 'ERROR':
                                        dataUpdates.lastError = value;
                                        break;
                                    case 'STATUS':
                                        // Parse status information like "OBD=REAL,GPS=OK,STORAGE=OK"
                                        const statusPairs = value.split(',');
                                        const statusObj = {};
                                        statusPairs.forEach(statusPair => {
                                            const [statusKey, statusValue] = statusPair.split('=');
                                            if (statusKey && statusValue) {
                                                statusObj[statusKey] = statusValue;
                                            }
                                        });
                                        dataUpdates.systemStatus = statusObj;
                                        break;
                                    case 'API_VERSION':
                                        const apiVersion = parseInt(value);
                                        dataUpdates.apiVersion = apiVersion;
                                        validateApiVersion(apiVersion);
                                        break;
                                    case 'CONNECT':
                                        // Handle connection messages that may include API_VERSION
                                        if (value.includes('API_VERSION:')) {
                                            const versionMatch = value.match(/API_VERSION:(\d+)/);
                                            if (versionMatch) {
                                                const apiVersion = parseInt(versionMatch[1]);
                                                dataUpdates.apiVersion = apiVersion;
                                                validateApiVersion(apiVersion);
                                            }
                                        }
                                        break;
                                    case 'DIAGNOSTIC_STARTED':
                                        try {
                                            setDiagnosticRunning(true);
                                            setDiagnosticError(null);
                                            setDiagnosticResults('Diagnostic mode started... Running comprehensive system checks...');
                                        } catch (diagError) {
                                            console.error('Error handling diagnostic start:', diagError);
                                            setDiagnosticError('Failed to start diagnostic process');
                                        }
                                        break;
                                    case 'DIAGNOSTIC_RESULTS':
                                        try {
                                            if (!value || typeof value !== 'string') {
                                                throw new Error('Invalid diagnostic results format');
                                            }
                                            const results = value.replace(/\|/g, '\n'); // Convert pipe separators back to newlines
                                            setDiagnosticResults(prev => {
                                                const currentResults = prev || '';
                                                return currentResults + (currentResults ? '\n' : '') + results;
                                            });
                                            setDiagnosticError(null);
                                        } catch (diagError) {
                                            console.error('Error processing diagnostic results:', diagError);
                                            setDiagnosticError('Failed to process diagnostic results: ' + diagError.message);
                                            setDiagnosticResults(prev => (prev || '') + '\n❌ Error processing results: ' + diagError.message);
                                        }
                                        break;
                                    case 'DIAGNOSTIC_COMPLETE':
                                        try {
                                            setDiagnosticRunning(false);
                                            if (value === 'SUCCESS') {
                                                setDiagnosticResults(prev => (prev || '') + '\n\n✅ Diagnostic completed successfully!');
                                                setDiagnosticError(null);
                                            } else if (value === 'FAILED' || value === 'ERROR') {
                                                setDiagnosticResults(prev => (prev || '') + '\n\n❌ Diagnostic completed with errors!');
                                                setDiagnosticError('Diagnostic process completed with errors');
                                            } else {
                                                setDiagnosticResults(prev => (prev || '') + '\n\n⚠️ Diagnostic completed with unknown status: ' + value);
                                            }
                                        } catch (diagError) {
                                            console.error('Error handling diagnostic completion:', diagError);
                                            setDiagnosticError('Failed to complete diagnostic process');
                                            setDiagnosticRunning(false);
                                        }
                                        break;
                                }
                            }
                        });

                        // Only update state if we have actual data to update
                        if (Object.keys(dataUpdates).length > 1) { // More than just timestamp
                            setData(prev => {
                                const newData = { ...prev, ...dataUpdates };
                                
                                // Handle GPS updates properly by merging with existing GPS data
                                if (dataUpdates.gps) {
                                    newData.gps = { ...prev.gps, ...dataUpdates.gps };
                                }
                                
                                return newData;
                            });

                            // Add to history for charting only if we have sensor data
                            if (hasSensorData) {
                                setDataHistory(prev => {
                                    const currentData = prev.length > 0 ? prev[prev.length - 1] : {
                                        rpm: 0, speed: 0, coolant: 0, enginePressure: 0, batteryVoltage: 0,
                                        ambientTemp: 0, engineLoad: 0, throttlePos: 0, intakeTemp: 0, oilTemp: 0,
                                        exhaustTemp: 0, fuelPressure: 0, fuelLevel: 0, fuelTrimShort: 0,
                                        fuelTrimLong: 0, fuelRate: 0, mafFlow: 0, o2Voltage: 0, catalystTemp: 0,
                                        boostPressure: 0, turboRpm: 0
                                    };
                                    
                                    return [...prev, {
                                        timestamp: Date.now(),
                                        rpm: dataUpdates.rpm !== undefined ? dataUpdates.rpm : currentData.rpm,
                                        speed: dataUpdates.speed !== undefined ? dataUpdates.speed : currentData.speed,
                                        coolant: dataUpdates.coolant !== undefined ? dataUpdates.coolant : currentData.coolant,
                                        enginePressure: dataUpdates.enginePressure !== undefined ? dataUpdates.enginePressure : currentData.enginePressure,
                                        batteryVoltage: dataUpdates.batteryVoltage !== undefined ? dataUpdates.batteryVoltage : currentData.batteryVoltage,
                                        ambientTemp: dataUpdates.ambientTemp !== undefined ? dataUpdates.ambientTemp : currentData.ambientTemp,
                                        engineLoad: dataUpdates.engineLoad !== undefined ? dataUpdates.engineLoad : currentData.engineLoad,
                                        throttlePos: dataUpdates.throttlePos !== undefined ? dataUpdates.throttlePos : currentData.throttlePos,
                                        intakeTemp: dataUpdates.intakeTemp !== undefined ? dataUpdates.intakeTemp : currentData.intakeTemp,
                                        oilTemp: dataUpdates.oilTemp !== undefined ? dataUpdates.oilTemp : currentData.oilTemp,
                                        exhaustTemp: dataUpdates.exhaustTemp !== undefined ? dataUpdates.exhaustTemp : currentData.exhaustTemp,
                                        fuelPressure: dataUpdates.fuelPressure !== undefined ? dataUpdates.fuelPressure : currentData.fuelPressure,
                                        fuelLevel: dataUpdates.fuelLevel !== undefined ? dataUpdates.fuelLevel : currentData.fuelLevel,
                                        fuelTrimShort: dataUpdates.fuelTrimShort !== undefined ? dataUpdates.fuelTrimShort : currentData.fuelTrimShort,
                                        fuelTrimLong: dataUpdates.fuelTrimLong !== undefined ? dataUpdates.fuelTrimLong : currentData.fuelTrimLong,
                                        fuelRate: dataUpdates.fuelRate !== undefined ? dataUpdates.fuelRate : currentData.fuelRate,
                                        mafFlow: dataUpdates.mafFlow !== undefined ? dataUpdates.mafFlow : currentData.mafFlow,
                                        o2Voltage: dataUpdates.o2Voltage !== undefined ? dataUpdates.o2Voltage : currentData.o2Voltage,
                                        catalystTemp: dataUpdates.catalystTemp !== undefined ? dataUpdates.catalystTemp : currentData.catalystTemp,
                                        boostPressure: dataUpdates.boostPressure !== undefined ? dataUpdates.boostPressure : currentData.boostPressure,
                                        turboRpm: dataUpdates.turboRpm !== undefined ? dataUpdates.turboRpm : currentData.turboRpm
                                    }].slice(-100); // Keep last 100 entries
                                });
                            }
                        }
                    }
                } catch (parseError) {
                    console.error('Error parsing data:', parseError);
                    
                    // Add parse error to error log with details
                    const errorDetails = {
                        timestamp: new Date().toLocaleTimeString(),
                        type: 'parse',
                        message: parseError.message,
                        rawData: rawData ? rawData.substring(0, 100) + (rawData.length > 100 ? '...' : '') : 'null'
                    };
                    
                    setDataParseErrors(prev => [...prev.slice(-9), errorDetails]); // Keep last 10 errors
                    
                    setRawDataLog(prev => [...prev.slice(-50), {
                        timestamp: new Date().toLocaleTimeString(),
                        data: `PARSE ERROR: ${parseError.message} | Raw: ${errorDetails.rawData}`,
                        type: 'error'
                    }]);
                }
            } catch (outerError) {
                console.error('Critical error in data handler:', outerError);
                
                setRawDataLog(prev => [...prev.slice(-50), {
                    timestamp: new Date().toLocaleTimeString(),
                    data: `CRITICAL ERROR: ${outerError.message} | Handler failed completely`,
                    type: 'error'
                }]);
                
                // Reset diagnostic state on critical errors
                setDiagnosticRunning(false);
                setDiagnosticError('Critical error in data processing');
            }

            const handleDisconnection = () => {
                console.log('Device disconnected');
                setIsConnected(false);
                setDevice(null);
                setCharacteristic(null);
                
                // Log disconnection
                setRawDataLog(prev => [...prev, {
                    timestamp: new Date().toLocaleTimeString(),
                    data: 'Device disconnected',
                    type: 'disconnect'
                }]);
            };

            const disconnect = () => {
                if (device && device.gatt.connected) {
                    device.gatt.disconnect();
                }
            };

            // Function to send commands to device with enhanced error handling
            const sendCommand = (command) => {
                try {
                    // Validate command input
                    if (!command || typeof command !== 'string' || command.trim().length === 0) {
                        throw new Error('Invalid command: empty or non-string command');
                    }
                    
                    // Sanitize command to prevent injection
                    const sanitizedCommand = command.trim().replace(/[^A-Z_]/g, '');
                    if (sanitizedCommand !== command.trim()) {
                        console.warn('Command sanitized:', command, '->', sanitizedCommand);
                    }
                    
                    if (characteristic && device && device.gatt && device.gatt.connected) {
                        try {
                            const message = `CMD:${sanitizedCommand}`;
                            
                            // Validate message length
                            if (message.length > 100) {
                                throw new Error('Command too long: ' + message.length + ' characters');
                            }
                            
                            characteristic.writeValue(new TextEncoder().encode(message));
                            console.log('Sent command:', message);
                            
                            setRawDataLog(prev => [...prev.slice(-50), {
                                timestamp: new Date().toLocaleTimeString(),
                                data: 'TX: ' + message,
                                type: 'tx'
                            }]);
                            
                            // Special handling for diagnostic commands
                            if (sanitizedCommand === 'DIAGNOSTIC') {
                                setDiagnosticError(null);
                                setTimeout(() => {
                                    if (diagnosticRunning) {
                                        setDiagnosticError('Diagnostic timeout - no response from device');
                                        setDiagnosticRunning(false);
                                    }
                                }, 30000); // 30 second timeout
                            }
                            
                        } catch (writeError) {
                            console.error('BLE write failed:', writeError);
                            setRawDataLog(prev => [...prev.slice(-50), {
                                timestamp: new Date().toLocaleTimeString(),
                                data: 'TX ERROR: BLE write failed for ' + sanitizedCommand + ' - ' + writeError.message,
                                type: 'error'
                            }]);
                            
                            if (sanitizedCommand === 'DIAGNOSTIC') {
                                setDiagnosticError('Failed to send diagnostic command: ' + writeError.message);
                                setDiagnosticRunning(false);
                            }
                        }
                    } else {
                        const connectionStatus = !device ? 'No device' : 
                                               !device.gatt ? 'No GATT' : 
                                               !device.gatt.connected ? 'Not connected' : 'Unknown state';
                        
                        console.warn('Cannot send command - device not connected:', connectionStatus);
                        setRawDataLog(prev => [...prev.slice(-50), {
                            timestamp: new Date().toLocaleTimeString(),
                            data: `TX ERROR: ${connectionStatus}, cannot send ${sanitizedCommand}`,
                            type: 'error'
                        }]);
                        
                        if (sanitizedCommand === 'DIAGNOSTIC') {
                            setDiagnosticError('Cannot run diagnostic: ' + connectionStatus);
                            setDiagnosticRunning(false);
                        }
                    }
                } catch (commandError) {
                    console.error('Command processing error:', commandError);
                    setRawDataLog(prev => [...prev.slice(-50), {
                        timestamp: new Date().toLocaleTimeString(),
                        data: 'COMMAND ERROR: ' + commandError.message,
                        type: 'error'
                    }]);
                    
                    if (command === 'DIAGNOSTIC') {
                        setDiagnosticError('Command processing error: ' + commandError.message);
                        setDiagnosticRunning(false);
                    }
                }
            };

            // Client-side simulation functions
            const generateSimulatedData = () => {
                const now = Date.now();
                const elapsed = clientSimulation.startTime ? (now - clientSimulation.startTime) / 1000 : 0;
                
                // Generate realistic simulated data
                const baseRpm = 1500 + Math.sin(elapsed * 0.1) * 300;
                const baseSpeed = 60 + Math.sin(elapsed * 0.05) * 15;
                
                return {
                    rpm: Math.round(baseRpm + (Math.random() - 0.5) * 200),
                    speed: Math.round(baseSpeed + (Math.random() - 0.5) * 10),
                    coolant: Math.round(185 + (Math.random() - 0.5) * 10), // °F
                    engineLoad: Math.round(25 + Math.sin(elapsed * 0.08) * 15 + (Math.random() - 0.5) * 10),
                    throttlePos: Math.round(20 + Math.sin(elapsed * 0.12) * 10 + (Math.random() - 0.5) * 8),
                    fuelLevel: Math.round(75 + (Math.random() - 0.5) * 5),
                    batteryVoltage: 14.2 + (Math.random() - 0.5) * 0.4,
                    ambientTemp: Math.round(72 + (Math.random() - 0.5) * 10), // °F
                    enginePressure: Math.round(35 + (Math.random() - 0.5) * 8),
                    intakeTemp: Math.round(95 + (Math.random() - 0.5) * 15), // °F
                    oilTemp: Math.round(210 + (Math.random() - 0.5) * 20), // °F
                    exhaustTemp: Math.round(800 + (Math.random() - 0.5) * 100), // °F
                    fuelPressure: Math.round(45 + (Math.random() - 0.5) * 8),
                    fuelTrimShort: Math.round((Math.random() - 0.5) * 10),
                    fuelTrimLong: Math.round((Math.random() - 0.5) * 6),
                    fuelRate: (8 + (Math.random() - 0.5) * 3).toFixed(1),
                    mafFlow: (15 + Math.sin(elapsed * 0.1) * 5 + (Math.random() - 0.5) * 2).toFixed(1),
                    o2Voltage: (0.45 + (Math.random() - 0.5) * 0.2).toFixed(3),
                    catalystTemp: Math.round(750 + (Math.random() - 0.5) * 100), // °F
                    boostPressure: Math.round((Math.random()) * 5), // Low boost for NA engine
                    turboRpm: 0, // No turbo
                    gps: {
                        lat: 37.7749 + (Math.random() - 0.5) * 0.01,
                        lng: -122.4194 + (Math.random() - 0.5) * 0.01,
                        satellites: 7 + Math.round((Math.random() - 0.5) * 4)
                    },
                    timestamp: now,
                    dataMode: 'SIMULATED'
                };
            };

            // Function to toggle client-side simulation
            const toggleSimulation = () => {
                if (clientSimulation.enabled) {
                    // Stop simulation
                    if (clientSimulation.interval) {
                        clearInterval(clientSimulation.interval);
                    }
                    setClientSimulation({
                        enabled: false,
                        startTime: null,
                        interval: null
                    });
                    setData(prev => ({
                        ...prev,
                        simulationRunning: false,
                        dataMode: 'DISABLED'
                    }));
                } else {
                    // Start simulation
                    const startTime = Date.now();
                    const interval = setInterval(() => {
                        const simData = generateSimulatedData();
                        setData(prev => ({
                            ...prev,
                            ...simData,
                            simulationRunning: true
                        }));
                        
                        // Add to history for charting
                        setDataHistory(prev => [...prev, {
                            timestamp: Date.now(),
                            rpm: simData.rpm || 0,
                            speed: simData.speed || 0,
                            coolant: simData.coolant || 0,
                            enginePressure: simData.enginePressure || 0,
                            batteryVoltage: simData.batteryVoltage || 0,
                            ambientTemp: simData.ambientTemp || 0,
                            engineLoad: simData.engineLoad || 0,
                            throttlePos: simData.throttlePos || 0,
                            intakeTemp: simData.intakeTemp || 0,
                            oilTemp: simData.oilTemp || 0,
                            exhaustTemp: simData.exhaustTemp || 0,
                            fuelPressure: simData.fuelPressure || 0,
                            fuelLevel: simData.fuelLevel || 0,
                            fuelTrimShort: simData.fuelTrimShort || 0,
                            fuelTrimLong: simData.fuelTrimLong || 0,
                            fuelRate: parseFloat(simData.fuelRate) || 0,
                            mafFlow: parseFloat(simData.mafFlow) || 0,
                            o2Voltage: parseFloat(simData.o2Voltage) || 0,
                            catalystTemp: simData.catalystTemp || 0,
                            boostPressure: simData.boostPressure || 0,
                            turboRpm: simData.turboRpm || 0
                        }].slice(-100));
                    }, 1000);
                    
                    setClientSimulation({
                        enabled: true,
                        startTime: startTime,
                        interval: interval
                    });
                    
                    setData(prev => ({
                        ...prev,
                        simulationRunning: true,
                        dataMode: 'SIMULATED'
                    }));
                }
            };

            // Periodic ping to keep connection alive
            useEffect(() => {
                if (isConnected) {
                    const pingInterval = setInterval(() => {
                        sendCommand('PING');
                    }, 30000); // Ping every 30 seconds

                    return () => clearInterval(pingInterval);
                }
            }, [isConnected]);

            // Helper function to get color class based on value and type with error handling
            const getColorClass = (value, type) => {
                try {
                    // Validate inputs
                    if (value === null || value === undefined || isNaN(value)) {
                        return 'info'; // Default for invalid values
                    }
                    
                    const numValue = Number(value);
                    if (!isFinite(numValue)) {
                        return 'info'; // Default for infinite or NaN values
                    }
                switch (type) {
                    case 'rpm':
                        if (value > 6000) return 'danger';
                        if (value > 4000) return 'warning';
                        return 'normal';
                    case 'speed':
                        if (value > 80) return 'danger';
                        if (value > 60) return 'warning';
                        return 'normal';
                    case 'coolant':
                        if (value > 220) return 'danger';
                        if (value > 200) return 'warning';
                        return 'normal';
                    case 'pressure':
                        if (value < 10) return 'danger';
                        if (value < 20) return 'warning';
                        return 'normal';
                    case 'battery':
                        if (value < 11.5) return 'danger';
                        if (value < 12.0) return 'warning';
                        return 'normal';
                    case 'ambient':
                        if (value > 100) return 'danger';
                        if (value > 85) return 'warning';
                        return 'normal';
                    case 'engineLoad':
                        if (value > 90) return 'danger';
                        if (value > 75) return 'warning';
                        return 'normal';
                    case 'throttle':
                        if (value > 90) return 'warning';
                        return 'normal';
                    case 'fuelLevel':
                        if (value < 15) return 'danger';
                        if (value < 25) return 'warning';
                        return 'normal';
                    case 'fuelTrim':
                        if (Math.abs(value) > 15) return 'danger';
                        if (Math.abs(value) > 10) return 'warning';
                        return 'normal';
                    case 'oilTemp':
                        if (value > 250) return 'danger';
                        if (value > 220) return 'warning';
                        return 'normal';
                    case 'exhaustTemp':
                        if (value > 1200) return 'danger';
                        if (value > 1000) return 'warning';
                        return 'normal';
                    default:
                        return 'info';
                }
            } catch (colorError) {
                console.warn('Error determining color class:', colorError, 'value:', value, 'type:', type);
                return 'info'; // Safe fallback
            }
            };

            return (
                <div className="dashboard">

                    {error && (
                        <div className="error-message">
                            {error}
                        </div>
                    )}

                    {!navigator.bluetooth && (
                        <div className="error-message">
                            Web Bluetooth is not supported in this browser. Please use Chrome or Edge with HTTPS enabled.
                            <br />
                            <small>Note: Safari has limited Web Bluetooth support. For best results, use Chrome or Edge.</small>
                        </div>
                    )}

                    {navigator.bluetooth && location.protocol !== 'https:' && location.hostname !== 'localhost' && (
                        <div className="error-message">
                            Web Bluetooth requires HTTPS. Please serve this page over HTTPS or use localhost for testing.
                        </div>
                    )}

                    <div className="status-panel">
                        <h3>System Status
                            <div className="status" style={{display: 'inline-flex', alignItems: 'center', marginLeft: '20px'}}>
                                <div className={`status-indicator ${isConnected ? 'connected' : ''}`}></div>
                                <span style={{marginLeft: '8px', marginRight: '10px'}}>{isConnected ? 'Connected' : 'Disconnected'}</span>
                                <button
                                    className="connect-btn"
                                    onClick={isConnected ? disconnect : connectToDevice}
                                    disabled={!navigator.bluetooth}
                                    style={{marginRight: '10px'}}
                                >
                                    {isConnected ? 'Disconnect' : 'Connect to Freematics'}
                                </button>
                            </div>
                            <button 
                                className={`sim-control-btn ${(data.simulationRunning || clientSimulation.enabled) ? 'stop' : ''}`}
                                onClick={toggleSimulation}
                                title={(data.simulationRunning || clientSimulation.enabled) ? 'Stop client simulation' : 'Start client simulation'}
                            >
                                {(data.simulationRunning || clientSimulation.enabled) ? '⏹ Stop Simulation' : '▶ Start Simulation'}
                            </button>
                            <button 
                                style={{marginLeft: '10px', padding: '8px 16px', fontSize: '14px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '5px', cursor: isConnected ? 'pointer' : 'not-allowed'}}
                                onClick={() => sendCommand('STATUS')}
                                disabled={!isConnected}
                                title="Request current system status"
                            >
                                🔄 Refresh Status
                            </button>
                            <button 
                                style={{marginLeft: '10px', padding: '8px 16px', fontSize: '14px', backgroundColor: '#dc3545', color: 'white', border: 'none', borderRadius: '5px', cursor: isConnected ? 'pointer' : 'not-allowed'}}
                                onClick={() => sendCommand('DIAGNOSTIC')}
                                disabled={!isConnected}
                                title="Run comprehensive hardware and system diagnostics"
                            >
                                🔧 Run Diagnostics
                            </button>
                        </h3>
                        <div>
                            <span className={`status-item ${data.dataMode.toLowerCase()}`}>
                                Data: {data.dataMode}
                            </span>
                            {Object.entries(data.systemStatus).map(([key, value]) => {
                                // Extract base status and indicator
                                const hasIndicator = value.includes('(') && value.includes(')');
                                const baseValue = hasIndicator ? value.split('(')[0] : value;
                                const indicator = hasIndicator ? value.match(/\(([^)]+)\)/)[1] : null;
                                
                                return (
                                    <span key={key} className={`status-item ${baseValue.toLowerCase()}`}>
                                        {key}: {baseValue}
                                        {indicator && (
                                            <small style={{fontSize: '0.7em', opacity: 0.8, marginLeft: '3px'}}>
                                                ({indicator})
                                            </small>
                                        )}
                                    </span>
                                );
                            })}
                        </div>
                        {data.lastError && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#f8d7da', color: '#721c24', borderRadius: '4px'}}>
                                <strong>Last Error:</strong> {data.lastError}
                            </div>
                        )}
                        {data.dataMode === 'DISABLED' && !clientSimulation.enabled && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#e2e3e5', color: '#6c757d', borderRadius: '4px'}}>
                                <strong>Info:</strong> Data collection is disabled. Click "Start Simulation" to begin receiving test data, or connect to a vehicle's OBD-II port for real data.
                            </div>
                        )}
                        {(data.dataMode === 'SIMULATED' || clientSimulation.enabled) && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#fff3cd', color: '#856404', borderRadius: '4px'}}>
                                <strong>Client Simulation Mode:</strong> Displaying realistic test data generated in the browser. All engine, fuel, emissions, and diagnostic parameters are simulated locally.
                            </div>
                        )}
                        {data.dataMode === 'REAL' && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#d4edda', color: '#155724', borderRadius: '4px'}}>
                                <strong>Real Vehicle Data:</strong> Connected to vehicle ECU. Displaying live sensor readings from engine, emissions, and diagnostic systems.
                            </div>
                        )}
                        <div style={{marginTop: '10px', fontSize: '0.9em', color: '#6c757d'}}>
                            <strong>Data Sources:</strong><br/>
                            • <strong>REAL:</strong> Live vehicle OBD-II data from device<br/>
                            • <strong>SIMULATED:</strong> Client-side test data generated in browser<br/>
                            • <strong>DISABLED:</strong> No data collection (hardware sensors only)<br/>
                            <strong>Controls:</strong> Use buttons to toggle client simulation or refresh device status.
                        </div>
                    </div>

                    <div className="metrics-grid">
                        <div className="metric-card">
                            <div className="metric-label">Engine RPM</div>
                            <div className={`metric-value ${getColorClass(data.rpm, 'rpm')}`}>{data.rpm.toLocaleString()}</div>
                            {(data.dataMode === 'SIMULATED' || clientSimulation.enabled) && <small style={{color: '#856404'}}>Simulated Data</small>}
                            {data.dataMode === 'DISABLED' && !clientSimulation.enabled && <small style={{color: '#6c757d'}}>No Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Speed</div>
                            <div className={`metric-value ${getColorClass(data.speed, 'speed')}`}>{data.speed} <small>mph</small></div>
                            {(data.dataMode === 'SIMULATED' || clientSimulation.enabled) && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Coolant Temp</div>
                            <div className={`metric-value ${getColorClass(data.coolant, 'coolant')}`}>{data.coolant}°F</div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Engine Pressure</div>
                            <div className={`metric-value ${getColorClass(data.enginePressure, 'pressure')}`}>{data.enginePressure} <small>psi</small></div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Battery Voltage</div>
                            <div className={`metric-value ${getColorClass(data.batteryVoltage, 'battery')}`}>{data.batteryVoltage.toFixed(1)} <small>V</small></div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Ambient Temp</div>
                            <div className={`metric-value ${getColorClass(data.ambientTemp, 'ambient')}`}>{data.ambientTemp}°F</div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">GPS Satellites</div>
                            <div className="metric-value info">
                                {data.gps.satellites}
                                {data.gps.satelliteIndicator && (
                                    <small style={{color: '#856404', display: 'block', fontSize: '0.4em', marginTop: '5px'}}>
                                        {data.gps.satelliteIndicator}
                                    </small>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="tabs">
                        <div 
                            className={`tab ${activeTab === 'overview' ? 'active' : ''}`}
                            onClick={() => setActiveTab('overview')}
                        >
                            Overview
                        </div>
                        <div 
                            className={`tab ${activeTab === 'performance' ? 'active' : ''}`}
                            onClick={() => setActiveTab('performance')}
                        >
                            Performance
                        </div>
                        <div 
                            className={`tab ${activeTab === 'temperatures' ? 'active' : ''}`}
                            onClick={() => setActiveTab('temperatures')}
                        >
                            Temperatures
                        </div>
                        <div 
                            className={`tab ${activeTab === 'percentages' ? 'active' : ''}`}
                            onClick={() => setActiveTab('percentages')}
                        >
                            Load & Levels
                        </div>
                        <div 
                            className={`tab ${activeTab === 'fuel' ? 'active' : ''}`}
                            onClick={() => setActiveTab('fuel')}
                        >
                            Fuel System
                        </div>
                        <div 
                            className={`tab ${activeTab === 'diagnostics' ? 'active' : ''}`}
                            onClick={() => setActiveTab('diagnostics')}
                        >
                            Diagnostics
                        </div>
                    </div>

                    <div className="tab-content">
                        <div className={`tab-panel ${activeTab === 'overview' ? 'active' : ''}`}>
                            <div className="compact-metrics">
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.engineLoad, 'engineLoad')}`}>
                                        {data.engineLoad}%
                                    </div>
                                    <div className="compact-label">Engine Load</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.throttlePos, 'throttle')}`}>
                                        {data.throttlePos}%
                                    </div>
                                    <div className="compact-label">Throttle Position</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.fuelLevel, 'fuelLevel')}`}>
                                        {data.fuelLevel}%
                                    </div>
                                    <div className="compact-label">Fuel Level</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.intakeTemp, 'ambient')}`}>
                                        {data.intakeTemp}°F
                                    </div>
                                    <div className="compact-label">Intake Temp</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.oilTemp, 'oilTemp')}`}>
                                        {data.oilTemp}°F
                                    </div>
                                    <div className="compact-label">Oil Temp</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.fuelPressure, 'pressure')}`}>
                                        {data.fuelPressure} psi
                                    </div>
                                    <div className="compact-label">Fuel Pressure</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.fuelTrimShort, 'fuelTrim')}`}>
                                        {data.fuelTrimShort > 0 ? '+' : ''}{data.fuelTrimShort}%
                                    </div>
                                    <div className="compact-label">Short Fuel Trim</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.fuelTrimLong, 'fuelTrim')}`}>
                                        {data.fuelTrimLong > 0 ? '+' : ''}{data.fuelTrimLong}%
                                    </div>
                                    <div className="compact-label">Long Fuel Trim</div>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-panel ${activeTab === 'performance' ? 'active' : ''}`}>
                            <div className="chart-container">
                                <div className="chart-wrapper">
                                    <canvas ref={chartRef}></canvas>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-panel ${activeTab === 'temperatures' ? 'active' : ''}`}>
                            <div className="chart-container">
                                <div className="chart-wrapper">
                                    <canvas ref={tempChartRef}></canvas>
                                </div>
                            </div>
                            <div className="compact-metrics">
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.catalystTemp, 'exhaustTemp')}`}>
                                        {data.catalystTemp}°F
                                    </div>
                                    <div className="compact-label">Catalyst Temp</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.exhaustTemp, 'exhaustTemp')}`}>
                                        {data.exhaustTemp}°F
                                    </div>
                                    <div className="compact-label">Exhaust Temp</div>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-panel ${activeTab === 'percentages' ? 'active' : ''}`}>
                            <div className="chart-container">
                                <div className="chart-wrapper">
                                    <canvas ref={percentChartRef}></canvas>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-panel ${activeTab === 'fuel' ? 'active' : ''}`}>
                            <div className="chart-container">
                                <div className="chart-wrapper">
                                    <canvas ref={fuelChartRef}></canvas>
                                </div>
                            </div>
                            <div className="compact-metrics">
                                <div className="compact-metric">
                                    <div className="compact-value info">
                                        {data.fuelRate.toFixed(2)} L/h
                                    </div>
                                    <div className="compact-label">Fuel Rate</div>
                                </div>
                                <div className="compact-metric">
                                    <div className="compact-value info">
                                        {data.mafFlow.toFixed(2)} g/s
                                    </div>
                                    <div className="compact-label">MAF Flow</div>
                                </div>
                                <div className="compact-metric">
                                    <div className="compact-value info">
                                        {data.o2Voltage.toFixed(3)} V
                                    </div>
                                    <div className="compact-label">O2 Sensor</div>
                                </div>
                            </div>
                        </div>

                        <div className={`tab-panel ${activeTab === 'diagnostics' ? 'active' : ''}`}>
                            {/* Error Display Section */}
                            {(diagnosticError || dataParseErrors.length > 0) && (
                                <div style={{marginBottom: '20px'}}>
                                    {diagnosticError && (
                                        <div style={{
                                            backgroundColor: '#f8d7da', 
                                            color: '#721c24', 
                                            padding: '10px', 
                                            borderRadius: '5px',
                                            marginBottom: '10px',
                                            border: '1px solid #f5c6cb'
                                        }}>
                                            <strong>🚨 Diagnostic Error:</strong> {diagnosticError}
                                            <button 
                                                style={{
                                                    marginLeft: '10px', 
                                                    padding: '2px 8px', 
                                                    fontSize: '0.8em', 
                                                    backgroundColor: '#dc3545', 
                                                    color: 'white', 
                                                    border: 'none', 
                                                    borderRadius: '3px',
                                                    cursor: 'pointer'
                                                }}
                                                onClick={() => setDiagnosticError(null)}
                                                title="Clear diagnostic error"
                                            >
                                                ✕ Clear
                                            </button>
                                        </div>
                                    )}
                                    
                                    {dataParseErrors.length > 0 && (
                                        <div style={{
                                            backgroundColor: '#fff3cd', 
                                            color: '#856404', 
                                            padding: '10px', 
                                            borderRadius: '5px',
                                            border: '1px solid #ffeaa7'
                                        }}>
                                            <strong>⚠️ Data Parse Errors ({dataParseErrors.length}):</strong>
                                            <button 
                                                style={{
                                                    marginLeft: '10px', 
                                                    padding: '2px 8px', 
                                                    fontSize: '0.8em', 
                                                    backgroundColor: '#ffc107', 
                                                    color: 'black', 
                                                    border: 'none', 
                                                    borderRadius: '3px',
                                                    cursor: 'pointer'
                                                }}
                                                onClick={() => setDataParseErrors([])}
                                                title="Clear parse errors"
                                            >
                                                ✕ Clear
                                            </button>
                                            <div style={{fontSize: '0.8em', marginTop: '5px', maxHeight: '100px', overflowY: 'auto'}}>
                                                {dataParseErrors.slice(-3).map((error, idx) => (
                                                    <div key={idx} style={{marginTop: '3px'}}>
                                                        <strong>{error.timestamp}:</strong> {error.message}
                                                        <br/><small>Data: {error.rawData}</small>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            <div className="compact-metrics">
                                <div className="compact-metric">
                                    <div className="compact-value info">
                                        {(data.boostPressure || 0)} psi
                                    </div>
                                    <div className="compact-label">Boost Pressure</div>
                                </div>
                                <div className="compact-metric">
                                    <div className="compact-value info">
                                        {(data.turboRpm || 0).toLocaleString()} RPM
                                    </div>
                                    <div className="compact-label">Turbo RPM</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.batteryVoltage, 'battery')}`}>
                                        {(data.batteryVoltage || 0).toFixed(1)} V
                                    </div>
                                    <div className="compact-label">Battery Voltage</div>
                                </div>
                                <div className="compact-metric">
                                    <div className={`compact-value ${getColorClass(data.enginePressure, 'pressure')}`}>
                                        {(data.enginePressure || 0)} psi
                                    </div>
                                    <div className="compact-label">Engine Pressure</div>
                                </div>
                            </div>
                            
                            <div style={{marginTop: '20px', padding: '15px', backgroundColor: '#f8f9fa', borderRadius: '8px'}}>
                                <h4>System Health Summary</h4>
                                <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '0.9em'}}>
                                    <div><strong>Engine Load:</strong> {(data.engineLoad || 0)}% {(data.engineLoad || 0) > 85 ? '⚠️' : '✅'}</div>
                                    <div><strong>Coolant Temp:</strong> {(data.coolant || 0)}°F {(data.coolant || 0) > 220 ? '🔥' : '✅'}</div>
                                    <div><strong>Oil Temp:</strong> {(data.oilTemp || 0)}°F {(data.oilTemp || 0) > 250 ? '🔥' : '✅'}</div>
                                    <div><strong>Fuel Level:</strong> {(data.fuelLevel || 0)}% {(data.fuelLevel || 0) < 25 ? '⛽' : '✅'}</div>
                                    <div><strong>Battery:</strong> {(data.batteryVoltage || 0).toFixed(1)}V {(data.batteryVoltage || 0) < 12.0 ? '🔋' : '✅'}</div>
                                    <div><strong>Fuel Trim:</strong> {Math.abs(data.fuelTrimShort || 0) > 10 ? '⚠️' : '✅'} ST: {(data.fuelTrimShort || 0)}%</div>
                                </div>
                            </div>

                            <div style={{marginTop: '20px', padding: '15px', backgroundColor: '#e3f2fd', borderRadius: '8px'}}>
                                <h4>Hardware Diagnostics 
                                    <button 
                                        style={{marginLeft: '10px', padding: '5px 10px', fontSize: '0.8em', backgroundColor: '#dc3545', color: 'white', border: 'none', borderRadius: '5px', cursor: isConnected && !diagnosticRunning ? 'pointer' : 'not-allowed'}}
                                        onClick={() => sendCommand('DIAGNOSTIC')}
                                        disabled={!isConnected || diagnosticRunning}
                                        title="Run comprehensive hardware and system diagnostics"
                                    >
                                        {diagnosticRunning ? '🔄 Running...' : '🔧 Run Full Diagnostic'}
                                    </button>
                                </h4>
                                
                                {diagnosticResults ? (
                                    <div style={{
                                        backgroundColor: diagnosticError ? '#fff5f5' : '#f8f9fa', 
                                        padding: '10px', 
                                        borderRadius: '5px', 
                                        fontFamily: 'monospace', 
                                        fontSize: '0.8em', 
                                        whiteSpace: 'pre-wrap',
                                        maxHeight: '400px',
                                        overflowY: 'auto',
                                        border: diagnosticError ? '1px solid #f5c6cb' : '1px solid #dee2e6'
                                    }}>
                                        {diagnosticResults}
                                        {diagnosticRunning && (
                                            <div style={{
                                                marginTop: '10px', 
                                                padding: '5px', 
                                                backgroundColor: '#e3f2fd', 
                                                borderRadius: '3px',
                                                textAlign: 'center',
                                                animation: 'pulse 1.5s infinite'
                                            }}>
                                                🔄 Diagnostic in progress... Please wait.
                                            </div>
                                        )}
                                    </div>
                                ) : (
                                    <div style={{padding: '20px', textAlign: 'center', color: '#6c757d', fontStyle: 'italic'}}>
                                        {isConnected ? (
                                            <>
                                                Click "Run Full Diagnostic" to scan hardware, pins, buses, and system components.
                                                <br />
                                                This will help identify connection issues, hardware problems, and configuration errors.
                                            </>
                                        ) : (
                                            <>
                                                🔌 Connect to a device first to run diagnostics.
                                                <br />
                                                Diagnostics require an active BLE connection to the Freematics device.
                                            </>
                                        )}
                                    </div>
                                )}
                                
                                <div style={{marginTop: '10px', fontSize: '0.85em', color: '#6c757d'}}>
                                    <strong>Diagnostic Features:</strong><br/>
                                    • ADC pin voltage testing (GPIO 36, 39, 34, 35, 32, 33, etc.)<br/>
                                    • Digital pin state checking (GPIO 2, 4, 5, 16, 17, 18, etc.)<br/>
                                    • I2C bus scanning for connected devices (SDA=21, SCL=22)<br/>
                                    • SPI pin state verification (MISO=19, MOSI=23, SCK=18, SS=5)<br/>
                                    • OBD-II interface testing with multiple baud rates<br/>
                                    • ESP32 system information and health checks<br/>
                                    • Power supply voltage analysis<br/>
                                    • BLE connectivity verification<br/>
                                    • Automatic issue detection and recommendations
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className="gps-container">
                        <h3>GPS Location</h3>
                        <div className="gps-coords">
                            Latitude: {data.gps.lat.toFixed(6)}°
                        </div>
                        <div className="gps-coords">
                            Longitude: {data.gps.lng.toFixed(6)}°
                        </div>
                        <div className="gps-coords">
                            Satellites: {data.gps.satellites}
                            {data.gps.satelliteIndicator && (
                                <small style={{color: '#856404', marginLeft: '10px'}}>
                                    {data.gps.satelliteIndicator}
                                </small>
                            )}
                        </div>
                    </div>

                    <div className="data-log">
                        <h3>Raw Data Log 
                            <button 
                                style={{marginLeft: '10px', padding: '5px 10px', fontSize: '0.8em'}}
                                onClick={() => sendCommand('STATUS')}
                                disabled={!isConnected}
                            >
                                Request Status
                            </button>
                            <button 
                                style={{marginLeft: '5px', padding: '5px 10px', fontSize: '0.8em'}}
                                onClick={() => setRawDataLog([])}
                            >
                                Clear Log
                            </button>
                        </h3>
                        {rawDataLog.slice(-20).reverse().map((entry, index) => (
                            <div key={index} className={`log-entry ${entry.type || 'data'}`}>
                                <strong>{entry.timestamp}:</strong> {entry.data}
                            </div>
                        ))}
                        {rawDataLog.length === 0 && (
                            <div className="log-entry">No data received yet...</div>
                        )}
                        <div style={{marginTop: '10px', fontSize: '0.9em', color: '#6c757d'}}>
                            Total messages: {rawDataLog.length} | 
                            Connected: {isConnected ? 'Yes' : 'No'} |
                            API Version: {data.apiVersion !== null ? data.apiVersion : 'Unknown'} |
                            Last update: {rawDataLog.length > 0 ? rawDataLog[rawDataLog.length - 1].timestamp : 'Never'}
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FreematicsDashboard />);
    </script>
</body>
</html>
