<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freematics BLE Dashboard</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .connect-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .connect-btn:hover {
            background: #0056b3;
        }
        .connect-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        .status-indicator.connected {
            background: #28a745;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #007bff;
            margin: 10px 0;
        }
        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .gps-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .gps-coords {
            font-family: monospace;
            font-size: 1.1em;
            color: #495057;
            margin: 10px 0;
        }
        .data-log {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .log-entry {
            font-family: monospace;
            font-size: 0.9em;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function FreematicsDashboard() {
            const [isConnected, setIsConnected] = useState(false);
            const [device, setDevice] = useState(null);
            const [characteristic, setCharacteristic] = useState(null);
            const [error, setError] = useState(null);
            const [data, setData] = useState({
                rpm: 0,
                speed: 0,
                coolant: 0,
                gps: { lat: 0, lng: 0, satellites: 0 },
                timestamp: 0
            });
            const [dataHistory, setDataHistory] = useState([]);
            const [rawDataLog, setRawDataLog] = useState([]);

            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            // Initialize chart
            useEffect(() => {
                if (chartRef.current && !chartInstance.current) {
                    const ctx = chartRef.current.getContext('2d');
                    chartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'RPM',
                                    data: [],
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Speed (km/h)',
                                    data: [],
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: {
                                        display: true,
                                        text: 'Time (seconds)'
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'RPM'
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    title: {
                                        display: true,
                                        text: 'Speed (km/h)'
                                    },
                                    grid: {
                                        drawOnChartArea: false,
                                    },
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Vehicle Data Over Time'
                                }
                            }
                        }
                    });
                }
            }, []);

            // Update chart when data changes
            useEffect(() => {
                if (chartInstance.current && dataHistory.length > 0) {
                    const chart = chartInstance.current;
                    const startTime = dataHistory[0].timestamp;

                    chart.data.labels = dataHistory.map(d => ((d.timestamp - startTime) / 1000).toFixed(1));
                    chart.data.datasets[0].data = dataHistory.map(d => d.rpm);
                    chart.data.datasets[1].data = dataHistory.map(d => d.speed);

                    // Keep only last 50 data points for performance
                    if (chart.data.labels.length > 50) {
                        chart.data.labels = chart.data.labels.slice(-50);
                        chart.data.datasets[0].data = chart.data.datasets[0].data.slice(-50);
                        chart.data.datasets[1].data = chart.data.datasets[1].data.slice(-50);
                    }

                    chart.update('none');
                }
            }, [dataHistory]);

            const connectToDevice = async () => {
                try {
                    setError(null);

                    if (!navigator.bluetooth) {
                        throw new Error('Web Bluetooth is not supported in this browser. Please use Chrome/Edge with HTTPS.');
                    }

                    // Check if we're on HTTPS (required for Web Bluetooth)
                    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                        throw new Error('Web Bluetooth requires HTTPS. Please serve this page over HTTPS.');
                    }

                    console.log('Requesting Bluetooth device...');
                    const device = await navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: [
                            '12345678-1234-1234-1234-123456789abc',
                            '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                            '0000180a-0000-1000-8000-00805f9b34fb'  // Device Information Service
                        ]
                    }).catch(err => {
                        if (err.name === 'NotFoundError') {
                            throw new Error('No Bluetooth device found. Make sure the device is powered on and in range.');
                        }
                        throw err;
                    });

                    console.log('Connecting to GATT server...');
                    console.log('Device name:', device.name);
                    console.log('Device ID:', device.id);
                    
                    const server = await device.gatt.connect();


                    console.log('Getting service...');
                    let service;
                    try {
                        service = await server.getPrimaryService('12345678-1234-1234-1234-123456789abc');
                    } catch (serviceErr) {
                        console.error('Service not found, trying to discover available services...');
                        
                        // Try to get all available services for debugging
                        try {
                            const services = await server.getPrimaryServices();
                            console.log('Available services:', services.map(s => s.uuid));
                            
                            // Try common service UUIDs
                            const commonServices = [
                                '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                                '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                                '6e400001-b5a3-f393-e0a9-e50e24dcca9e'  // Nordic UART Service
                            ];
                            
                            for (const serviceUuid of commonServices) {
                                try {
                                    service = await server.getPrimaryService(serviceUuid);
                                    console.log('Using service:', serviceUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!service && services.length > 0) {
                                // Use the first available service
                                service = services[0];
                                console.log('Using first available service:', service.uuid);
                            }
                        } catch (discoveryErr) {
                            console.error('Service discovery failed:', discoveryErr);
                        }
                        
                        if (!service) {
                            throw new Error('No compatible service found. Make sure the device is a Freematics device with BLE enabled.');
                        }
                    }

                    console.log('Getting characteristic...');
                    let characteristic;
                    try {
                        characteristic = await service.getCharacteristic('12345678-1234-1234-1234-123456789abc');
                    } catch (charErr) {
                        console.error('Characteristic not found, trying to discover available characteristics...');
                        
                        try {
                            const characteristics = await service.getCharacteristics();
                            console.log('Available characteristics:', characteristics.map(c => c.uuid));
                            
                            // Try common characteristic UUIDs
                            const commonCharacteristics = [
                                '6e400002-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART TX
                                '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART RX
                                '00002a19-0000-1000-8000-00805f9b34fb'  // Battery Level
                            ];
                            
                            for (const charUuid of commonCharacteristics) {
                                try {
                                    characteristic = await service.getCharacteristic(charUuid);
                                    console.log('Using characteristic:', charUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!characteristic && characteristics.length > 0) {
                                // Use the first available characteristic that supports notifications
                                for (const char of characteristics) {
                                    if (char.properties.notify || char.properties.read) {
                                        characteristic = char;
                                        console.log('Using first compatible characteristic:', char.uuid);
                                        break;
                                    }
                                }
                            }
                        } catch (discoveryErr) {
                            console.error('Characteristic discovery failed:', discoveryErr);
                        }
                        
                        if (!characteristic) {
                            throw new Error('No compatible characteristic found. Device may not support the expected BLE protocol.');
                        }
                    }

                    // Start notifications if supported
                    if (characteristic.properties.notify) {
                        await characteristic.startNotifications();
                        characteristic.addEventListener('characteristicvaluechanged', handleDataReceived);
                        console.log('Notifications started successfully');
                    } else if (characteristic.properties.read) {
                        console.log('Device supports read but not notifications, will poll for data');
                        // Set up polling for read-only characteristics
                        const pollData = async () => {
                            try {
                                const value = await characteristic.readValue();
                                handleDataReceived({ target: { value } });
                            } catch (readErr) {
                                console.error('Read error:', readErr);
                            }
                        };
                        setInterval(pollData, 1000); // Poll every second
                    } else {
                        console.warn('Characteristic does not support notifications or reading');
                    }

                    setDevice(device);
                    setCharacteristic(characteristic);
                    setIsConnected(true);

                    device.addEventListener('gattserverdisconnected', handleDisconnection);

                } catch (err) {
                    console.error('Connection failed:', err);
                    setError(`Connection failed: ${err.message}`);
                }
            };

            const handleDataReceived = (event) => {
                const value = event.target.value;
                const decoder = new TextDecoder();
                const rawData = decoder.decode(value);

                console.log('Received data:', rawData);

                // Add to raw data log
                setRawDataLog(prev => [...prev.slice(-20), {
                    timestamp: new Date().toLocaleTimeString(),
                    data: rawData
                }]);

                // Parse the data format: timestamp,RPM:value;SPD:value;GPS:lat,lng;
                try {
                    const parts = rawData.split(',');
                    if (parts.length >= 2) {
                        const timestamp = parseInt(parts[0]);
                        const dataString = parts.slice(1).join(',');

                        const newData = { ...data, timestamp };

                        // Parse key-value pairs
                        const pairs = dataString.split(';').filter(p => p.length > 0);

                        pairs.forEach(pair => {
                            if (pair.includes(':')) {
                                const [key, value] = pair.split(':');

                                switch (key) {
                                    case 'RPM':
                                        newData.rpm = parseInt(value) || 0;
                                        break;
                                    case 'SPD':
                                        newData.speed = parseInt(value) || 0;
                                        break;
                                    case 'COOLANT':
                                        newData.coolant = parseInt(value) || 0;
                                        break;
                                    case 'GPS':
                                        const coords = value.split(',');
                                        if (coords.length >= 2) {
                                            newData.gps = {
                                                ...newData.gps,
                                                lat: parseFloat(coords[0]) || 0,
                                                lng: parseFloat(coords[1]) || 0
                                            };
                                        }
                                        break;
                                }
                            }
                        });

                        setData(newData);

                        // Add to history for charting
                        setDataHistory(prev => [...prev, {
                            timestamp: Date.now(),
                            rpm: newData.rpm,
                            speed: newData.speed,
                            coolant: newData.coolant
                        }].slice(-100)); // Keep last 100 entries
                    }
                } catch (parseError) {
                    console.error('Error parsing data:', parseError);
                }
            };

            const handleDisconnection = () => {
                console.log('Device disconnected');
                setIsConnected(false);
                setDevice(null);
                setCharacteristic(null);
            };

            const disconnect = () => {
                if (device && device.gatt.connected) {
                    device.gatt.disconnect();
                }
            };

            return (
                <div className="dashboard">
                    <div className="header">
                        <h1>Freematics BLE Dashboard</h1>
                        <div className="status">
                            <div className={`status-indicator ${isConnected ? 'connected' : ''}`}></div>
                            <span>{isConnected ? 'Connected' : 'Disconnected'}</span>
                            <button
                                className="connect-btn"
                                onClick={isConnected ? disconnect : connectToDevice}
                                disabled={!navigator.bluetooth}
                            >
                                {isConnected ? 'Disconnect' : 'Connect to Freematics'}
                            </button>
                        </div>
                    </div>

                    {error && (
                        <div className="error-message">
                            {error}
                        </div>
                    )}

                    {!navigator.bluetooth && (
                        <div className="error-message">
                            Web Bluetooth is not supported in this browser. Please use Chrome or Edge with HTTPS enabled.
                            <br />
                            <small>Note: Safari has limited Web Bluetooth support. For best results, use Chrome or Edge.</small>
                        </div>
                    )}

                    {navigator.bluetooth && location.protocol !== 'https:' && location.hostname !== 'localhost' && (
                        <div className="error-message">
                            Web Bluetooth requires HTTPS. Please serve this page over HTTPS or use localhost for testing.
                        </div>
                    )}

                    <div className="metrics-grid">
                        <div className="metric-card">
                            <div className="metric-label">Engine RPM</div>
                            <div className="metric-value">{data.rpm.toLocaleString()}</div>
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Speed</div>
                            <div className="metric-value">{data.speed} <small>km/h</small></div>
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Coolant Temp</div>
                            <div className="metric-value">{data.coolant}°C</div>
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">GPS Satellites</div>
                            <div className="metric-value">{data.gps.satellites}</div>
                        </div>
                    </div>

                    <div className="chart-container">
                        <div className="chart-wrapper">
                            <canvas ref={chartRef}></canvas>
                        </div>
                    </div>

                    <div className="gps-container">
                        <h3>GPS Location</h3>
                        <div className="gps-coords">
                            Latitude: {data.gps.lat.toFixed(6)}°
                        </div>
                        <div className="gps-coords">
                            Longitude: {data.gps.lng.toFixed(6)}°
                        </div>
                        <div className="gps-coords">
                            Satellites: {data.gps.satellites}
                        </div>
                    </div>

                    <div className="data-log">
                        <h3>Raw Data Log</h3>
                        {rawDataLog.slice(-10).reverse().map((entry, index) => (
                            <div key={index} className="log-entry">
                                <strong>{entry.timestamp}:</strong> {entry.data}
                            </div>
                        ))}
                        {rawDataLog.length === 0 && (
                            <div className="log-entry">No data received yet...</div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FreematicsDashboard />, document.getElementById('root'));
    </script>
</body>
</html>
