<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Freematics BLE Dashboard</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #212529;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e9ecef;
            }
        }
        .dashboard {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        @media (prefers-color-scheme: dark) {
            .header {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .connect-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .connect-btn:hover {
            background: #0056b3;
        }
        .connect-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #dc3545;
        }
        .status-indicator.connected {
            background: #28a745;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        @media (prefers-color-scheme: dark) {
            .metric-card {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
            transition: color 0.3s ease;
        }
        .metric-value.normal { color: #28a745; }
        .metric-value.warning { color: #ffc107; }
        .metric-value.danger { color: #dc3545; }
        .metric-value.info { color: #007bff; }
        .metric-label {
            color: #6c757d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .chart-container {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        .gps-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        @media (prefers-color-scheme: dark) {
            .gps-container {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .gps-coords {
            font-family: monospace;
            font-size: 1.1em;
            color: #495057;
            margin: 10px 0;
        }
        .data-log {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .data-log {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .log-entry {
            font-family: monospace;
            font-size: 0.9em;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        
        @media (prefers-color-scheme: dark) {
            .log-entry {
                border-bottom: 1px solid #495057;
            }
        }
        .log-entry.error {
            color: #dc3545;
            background-color: #f8d7da;
            padding: 8px;
            border-radius: 4px;
            margin: 2px 0;
        }
        .log-entry.status {
            color: #0c5460;
            background-color: #d1ecf1;
            padding: 8px;
            border-radius: 4px;
            margin: 2px 0;
        }
        .log-entry.heartbeat {
            color: #155724;
            background-color: #d4edda;
            padding: 4px 8px;
            border-radius: 4px;
            margin: 1px 0;
            font-size: 0.8em;
        }
        .log-entry.connect {
            color: #004085;
            background-color: #cce5ff;
            padding: 8px;
            border-radius: 4px;
            margin: 2px 0;
            font-weight: bold;
        }
        .log-entry.disconnect {
            color: #721c24;
            background-color: #f5c6cb;
            padding: 8px;
            border-radius: 4px;
            margin: 2px 0;
            font-weight: bold;
        }
        .log-entry.tx {
            color: #856404;
            background-color: #fff3cd;
            padding: 6px 8px;
            border-radius: 4px;
            margin: 1px 0;
            font-style: italic;
        }
        .log-entry.system {
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 6px 8px;
            border-radius: 4px;
            margin: 1px 0;
        }
        .status-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .status-panel {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .status-item {
            display: inline-block;
            margin: 5px 10px;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        .status-item.real { background: #d4edda; color: #155724; }
        .status-item.simulated { background: #fff3cd; color: #856404; }
        .status-item.disabled { background: #e2e3e5; color: #6c757d; }
        .status-item.ok { background: #d4edda; color: #155724; }
        .status-item.fail { background: #f8d7da; color: #721c24; }
        .status-item.off { background: #e2e3e5; color: #6c757d; }
        .sim-control-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        .sim-control-btn:hover {
            background: #138496;
        }
        .sim-control-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .sim-control-btn.stop {
            background: #dc3545;
        }
        .sim-control-btn.stop:hover {
            background: #c82333;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .tabs {
            display: flex;
            background: white;
            border-radius: 8px 8px 0 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 0;
            overflow-x: auto;
        }
        
        @media (prefers-color-scheme: dark) {
            .tabs {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .tab {
            padding: 15px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        .tab:hover {
            background: #f8f9fa;
        }
        .tab.active {
            border-bottom-color: #007bff;
            background: #f8f9fa;
            color: #007bff;
        }
        .tab-content {
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        
        @media (prefers-color-scheme: dark) {
            .tab-content {
                background: #2d2d2d;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            }
        }
        .tab-panel {
            display: none;
        }
        .tab-panel.active {
            display: block;
        }
        .compact-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .compact-metric {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        
        @media (prefers-color-scheme: dark) {
            .compact-metric {
                background: #3a3a3a;
                border: 1px solid #495057;
            }
        }
        .compact-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        .compact-label {
            color: #6c757d;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        @media (max-width: 768px) {
            .dashboard {
                padding: 10px;
            }
            .header {
                padding: 15px;
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            .metric-card {
                padding: 15px 10px;
            }
            .metric-value {
                font-size: 2em;
            }
            .tab {
                padding: 12px 15px;
                font-size: 0.9em;
            }
            .tab-content {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function FreematicsDashboard() {
            const [isConnected, setIsConnected] = useState(false);
            const [device, setDevice] = useState(null);
            const [characteristic, setCharacteristic] = useState(null);
            const [error, setError] = useState(null);
            const [apiVersionError, setApiVersionError] = useState(null);
            const [data, setData] = useState({
                rpm: 0,
                speed: 0,
                coolant: 0,
                enginePressure: 0,
                batteryVoltage: 0,
                ambientTemp: 0,
                gps: { lat: 0, lng: 0, satellites: 0 },
                timestamp: 0,
                dataMode: 'DISABLED',
                lastError: '',
                systemStatus: {},
                simulationRunning: false,
                apiVersion: null
            });
            
            // Expected API version - update this when making breaking changes
            const EXPECTED_API_VERSION = 1;
            const [dataHistory, setDataHistory] = useState([]);
            const [rawDataLog, setRawDataLog] = useState([]);

            const chartRef = useRef(null);
            const chartInstance = useRef(null);

            // Initialize chart
            useEffect(() => {
                if (chartRef.current && !chartInstance.current) {
                    const ctx = chartRef.current.getContext('2d');
                    
                    // Detect dark mode
                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const textColor = isDarkMode ? '#e9ecef' : '#666';
                    const gridColor = isDarkMode ? '#495057' : '#e0e0e0';
                    
                    chartInstance.current = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'RPM',
                                    data: [],
                                    borderColor: '#007bff',
                                    backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                    yAxisID: 'y'
                                },
                                {
                                    label: 'Speed (mph)',
                                    data: [],
                                    borderColor: '#28a745',
                                    backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                    yAxisID: 'y1'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'linear',
                                    position: 'bottom',
                                    title: {
                                        display: true,
                                        text: 'Time (seconds)',
                                        color: textColor
                                    },
                                    ticks: {
                                        color: textColor
                                    },
                                    grid: {
                                        color: gridColor
                                    }
                                },
                                y: {
                                    type: 'linear',
                                    display: true,
                                    position: 'left',
                                    title: {
                                        display: true,
                                        text: 'RPM',
                                        color: textColor
                                    },
                                    ticks: {
                                        color: textColor
                                    },
                                    grid: {
                                        color: gridColor
                                    }
                                },
                                y1: {
                                    type: 'linear',
                                    display: true,
                                    position: 'right',
                                    title: {
                                        display: true,
                                        text: 'Speed (mph)',
                                        color: textColor
                                    },
                                    ticks: {
                                        color: textColor
                                    },
                                    grid: {
                                        drawOnChartArea: false,
                                        color: gridColor
                                    },
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: 'Vehicle Data Over Time',
                                    color: textColor
                                },
                                legend: {
                                    labels: {
                                        color: textColor
                                    }
                                }
                            }
                        }
                    });
                }
            }, []);

            // Update chart when data changes
            useEffect(() => {
                if (chartInstance.current && dataHistory.length > 0) {
                    const chart = chartInstance.current;
                    const startTime = dataHistory[0].timestamp;

                    chart.data.labels = dataHistory.map(d => ((d.timestamp - startTime) / 1000).toFixed(1));
                    chart.data.datasets[0].data = dataHistory.map(d => d.rpm);
                    chart.data.datasets[1].data = dataHistory.map(d => d.speed);

                    // Keep only last 50 data points for performance
                    if (chart.data.labels.length > 50) {
                        chart.data.labels = chart.data.labels.slice(-50);
                        chart.data.datasets[0].data = chart.data.datasets[0].data.slice(-50);
                        chart.data.datasets[1].data = chart.data.datasets[1].data.slice(-50);
                    }

                    chart.update('none');
                }
            }, [dataHistory]);

            const connectToDevice = async () => {
                try {
                    setError(null);

                    if (!navigator.bluetooth) {
                        throw new Error('Web Bluetooth is not supported in this browser. Please use Chrome/Edge with HTTPS.');
                    }

                    // Check if we're on HTTPS (required for Web Bluetooth)
                    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                        throw new Error('Web Bluetooth requires HTTPS. Please serve this page over HTTPS.');
                    }

                    console.log('Requesting Bluetooth device...');
                    
                    // Add connection event to log
                    setRawDataLog(prev => [...prev, {
                        timestamp: new Date().toLocaleTimeString(),
                        data: 'Initiating Bluetooth connection...',
                        type: 'system'
                    }]);
                    const device = await navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: [
                            '12345678-1234-1234-1234-123456789abc',
                            '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                            '0000180a-0000-1000-8000-00805f9b34fb'  // Device Information Service
                        ]
                    }).catch(err => {
                        if (err.name === 'NotFoundError') {
                            throw new Error('No Bluetooth device found. Make sure the device is powered on and in range.');
                        }
                        throw err;
                    });

                    console.log('Connecting to GATT server...');
                    console.log('Device name:', device.name);
                    console.log('Device ID:', device.id);
                    
                    const server = await device.gatt.connect();


                    console.log('Getting service...');
                    let service;
                    try {
                        service = await server.getPrimaryService('12345678-1234-1234-1234-123456789abc');
                    } catch (serviceErr) {
                        console.error('Service not found, trying to discover available services...');
                        
                        // Try to get all available services for debugging
                        try {
                            const services = await server.getPrimaryServices();
                            console.log('Available services:', services.map(s => s.uuid));
                            
                            // Try common service UUIDs
                            const commonServices = [
                                '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
                                '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
                                '6e400001-b5a3-f393-e0a9-e50e24dcca9e'  // Nordic UART Service
                            ];
                            
                            for (const serviceUuid of commonServices) {
                                try {
                                    service = await server.getPrimaryService(serviceUuid);
                                    console.log('Using service:', serviceUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!service && services.length > 0) {
                                // Use the first available service
                                service = services[0];
                                console.log('Using first available service:', service.uuid);
                            }
                        } catch (discoveryErr) {
                            console.error('Service discovery failed:', discoveryErr);
                        }
                        
                        if (!service) {
                            throw new Error('No compatible service found. Make sure the device is a Freematics device with BLE enabled.');
                        }
                    }

                    console.log('Getting characteristic...');
                    let characteristic;
                    try {
                        characteristic = await service.getCharacteristic('12345678-1234-1234-1234-123456789abc');
                    } catch (charErr) {
                        console.error('Characteristic not found, trying to discover available characteristics...');
                        
                        try {
                            const characteristics = await service.getCharacteristics();
                            console.log('Available characteristics:', characteristics.map(c => c.uuid));
                            
                            // Try common characteristic UUIDs
                            const commonCharacteristics = [
                                '6e400002-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART TX
                                '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART RX
                                '00002a19-0000-1000-8000-00805f9b34fb'  // Battery Level
                            ];
                            
                            for (const charUuid of commonCharacteristics) {
                                try {
                                    characteristic = await service.getCharacteristic(charUuid);
                                    console.log('Using characteristic:', charUuid);
                                    break;
                                } catch (e) {
                                    // Continue trying
                                }
                            }
                            
                            if (!characteristic && characteristics.length > 0) {
                                // Use the first available characteristic that supports notifications
                                for (const char of characteristics) {
                                    if (char.properties.notify || char.properties.read) {
                                        characteristic = char;
                                        console.log('Using first compatible characteristic:', char.uuid);
                                        break;
                                    }
                                }
                            }
                        } catch (discoveryErr) {
                            console.error('Characteristic discovery failed:', discoveryErr);
                        }
                        
                        if (!characteristic) {
                            throw new Error('No compatible characteristic found. Device may not support the expected BLE protocol.');
                        }
                    }

                    // Start notifications if supported
                    if (characteristic.properties.notify) {
                        await characteristic.startNotifications();
                        characteristic.addEventListener('characteristicvaluechanged', handleDataReceived);
                        console.log('Notifications started successfully');
                        
                        // Send initial ping to device
                        setTimeout(() => {
                            if (characteristic && device.gatt.connected) {
                                const pingMessage = 'CMD:PING';
                                characteristic.writeValue(new TextEncoder().encode(pingMessage));
                                console.log('Sent ping to device:', pingMessage);
                                
                                setRawDataLog(prev => [...prev, {
                                    timestamp: new Date().toLocaleTimeString(),
                                    data: 'TX: ' + pingMessage,
                                    type: 'tx'
                                }]);
                            }
                        }, 1000);
                        
                    } else if (characteristic.properties.read) {
                        console.log('Device supports read but not notifications, will poll for data');
                        // Set up polling for read-only characteristics
                        const pollData = async () => {
                            try {
                                const value = await characteristic.readValue();
                                handleDataReceived({ target: { value } });
                            } catch (readErr) {
                                console.error('Read error:', readErr);
                            }
                        };
                        setInterval(pollData, 1000); // Poll every second
                    } else {
                        console.warn('Characteristic does not support notifications or reading');
                    }

                    setDevice(device);
                    setCharacteristic(characteristic);
                    setIsConnected(true);

                    device.addEventListener('gattserverdisconnected', handleDisconnection);
                    
                    // Log successful connection
                    setRawDataLog(prev => [...prev, {
                        timestamp: new Date().toLocaleTimeString(),
                        data: `Connected to ${device.name || 'Unknown Device'}`,
                        type: 'connect'
                    }]);

                } catch (err) {
                    console.error('Connection failed:', err);
                    setError(`Connection failed: ${err.message}`);
                }
            };

            const validateApiVersion = (receivedVersion) => {
                if (receivedVersion === null || receivedVersion === undefined) {
                    setApiVersionError({
                        type: 'missing',
                        message: 'Device firmware does not report API version. Please update the firmware.'
                    });
                    return false;
                } else if (receivedVersion > EXPECTED_API_VERSION) {
                    setApiVersionError({
                        type: 'newer',
                        message: `Device firmware API version (${receivedVersion}) is newer than dashboard expects (${EXPECTED_API_VERSION}). Please update the dashboard.`
                    });
                    return false;
                } else if (receivedVersion < EXPECTED_API_VERSION) {
                    setApiVersionError({
                        type: 'older',
                        message: `Device firmware API version (${receivedVersion}) is older than dashboard expects (${EXPECTED_API_VERSION}). Please deploy updated firmware.`
                    });
                    return false;
                } else {
                    setApiVersionError(null);
                    return true;
                }
            };

            const handleDataReceived = (event) => {
                const value = event.target.value;
                const decoder = new TextDecoder();
                const rawData = decoder.decode(value);

                console.log('BLE RX:', rawData);

                // Add to raw data log with message type detection
                const logEntry = {
                    timestamp: new Date().toLocaleTimeString(),
                    data: rawData,
                    type: 'data'
                };

                // Detect message types for better logging
                if (rawData.includes('ERROR:')) {
                    logEntry.type = 'error';
                } else if (rawData.includes('STATUS:')) {
                    logEntry.type = 'status';
                } else if (rawData.includes('HEARTBEAT:')) {
                    logEntry.type = 'heartbeat';
                } else if (rawData.includes('CONNECT:')) {
                    logEntry.type = 'connect';
                } else if (rawData.includes('PONG:')) {
                    logEntry.type = 'pong';
                }

                setRawDataLog(prev => [...prev.slice(-50), logEntry]);

                // Handle simple status/heartbeat messages that don't contain sensor data
                if (rawData.startsWith('HEARTBEAT:') || rawData.startsWith('PONG:') || rawData.startsWith('ERROR:')) {
                    // These messages don't contain sensor data, so don't update the main data state
                    // Just handle any specific status updates they might contain
                    if (rawData.includes('MODE:')) {
                        const modeMatch = rawData.match(/MODE:(\w+)/);
                        if (modeMatch) {
                            const mode = modeMatch[1];
                            setData(prev => ({
                                ...prev,
                                dataMode: mode,
                                simulationRunning: (mode === 'SIMULATED')
                            }));
                        }
                    }
                    return; // Don't process as sensor data
                }

                // Parse the data format: messageId:timestamp,RPM:value;SPD:value;GPS:lat,lng;
                try {
                    // Handle message counter prefix (messageId:data)
                    let dataToProcess = rawData;
                    let messageId = null;
                    
                    if (rawData.includes(':') && rawData.match(/^\d+:/)) {
                        const colonIndex = rawData.indexOf(':');
                        messageId = parseInt(rawData.substring(0, colonIndex));
                        dataToProcess = rawData.substring(colonIndex + 1);
                        console.log('Message ID:', messageId, 'Data:', dataToProcess);
                    }
                    
                    const parts = dataToProcess.split(',');
                    if (parts.length >= 2) {
                        const timestamp = parseInt(parts[0]);
                        const dataString = parts.slice(1).join(',');

                        // Only create updates object for fields that are actually present
                        const dataUpdates = { timestamp };
                        let hasSensorData = false;

                        // Parse key-value pairs
                        const pairs = dataString.split(';').filter(p => p.length > 0);

                        pairs.forEach(pair => {
                            if (pair.includes(':')) {
                                const [key, value] = pair.split(':');

                                switch (key) {
                                    case 'RPM':
                                        dataUpdates.rpm = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'SPD':
                                        // Convert km/h to mph
                                        dataUpdates.speed = Math.round((parseInt(value) || 0) * 0.621371);
                                        hasSensorData = true;
                                        break;
                                    case 'COOLANT':
                                        // Convert Celsius to Fahrenheit
                                        dataUpdates.coolant = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'PRESSURE':
                                        dataUpdates.enginePressure = parseInt(value) || 0;
                                        hasSensorData = true;
                                        break;
                                    case 'BATTERY':
                                        dataUpdates.batteryVoltage = (parseInt(value) || 0) / 100; // Assuming value is in centivolt
                                        hasSensorData = true;
                                        break;
                                    case 'AMBIENT':
                                        // Convert Celsius to Fahrenheit
                                        dataUpdates.ambientTemp = Math.round(((parseInt(value) || 0) * 9/5) + 32);
                                        hasSensorData = true;
                                        break;
                                    case 'GPS':
                                        const coords = value.split(',');
                                        if (coords.length >= 2) {
                                            dataUpdates.gps = {
                                                lat: parseFloat(coords[0]) || 0,
                                                lng: parseFloat(coords[1]) || 0
                                            };
                                        }
                                        hasSensorData = true;
                                        break;
                                    case 'SAT':
                                        // Parse satellite count and indicator
                                        const satMatch = value.match(/^(\d+)(\([^)]+\))?/);
                                        if (satMatch) {
                                            dataUpdates.gps = {
                                                ...(dataUpdates.gps || {}),
                                                satellites: parseInt(satMatch[1]) || 0,
                                                satelliteIndicator: satMatch[2] || null
                                            };
                                        } else {
                                            dataUpdates.gps = {
                                                ...(dataUpdates.gps || {}),
                                                satellites: parseInt(value) || 0,
                                                satelliteIndicator: null
                                            };
                                        }
                                        break;
                                    case 'MODE':
                                        dataUpdates.dataMode = value;
                                        dataUpdates.simulationRunning = (value === 'SIMULATED');
                                        break;
                                    case 'ERROR':
                                        dataUpdates.lastError = value;
                                        break;
                                    case 'STATUS':
                                        // Parse status information like "OBD=REAL,GPS=OK,STORAGE=OK"
                                        const statusPairs = value.split(',');
                                        const statusObj = {};
                                        statusPairs.forEach(statusPair => {
                                            const [statusKey, statusValue] = statusPair.split('=');
                                            if (statusKey && statusValue) {
                                                statusObj[statusKey] = statusValue;
                                            }
                                        });
                                        dataUpdates.systemStatus = statusObj;
                                        break;
                                    case 'API_VERSION':
                                        const apiVersion = parseInt(value);
                                        dataUpdates.apiVersion = apiVersion;
                                        validateApiVersion(apiVersion);
                                        break;
                                    case 'CONNECT':
                                        // Handle connection messages that may include API_VERSION
                                        if (value.includes('API_VERSION:')) {
                                            const versionMatch = value.match(/API_VERSION:(\d+)/);
                                            if (versionMatch) {
                                                const apiVersion = parseInt(versionMatch[1]);
                                                dataUpdates.apiVersion = apiVersion;
                                                validateApiVersion(apiVersion);
                                            }
                                        }
                                        break;
                                }
                            }
                        });

                        // Only update state if we have actual data to update
                        if (Object.keys(dataUpdates).length > 1) { // More than just timestamp
                            setData(prev => {
                                const newData = { ...prev, ...dataUpdates };
                                
                                // Handle GPS updates properly by merging with existing GPS data
                                if (dataUpdates.gps) {
                                    newData.gps = { ...prev.gps, ...dataUpdates.gps };
                                }
                                
                                return newData;
                            });

                            // Add to history for charting only if we have sensor data
                            if (hasSensorData) {
                                setDataHistory(prev => [...prev, {
                                    timestamp: Date.now(),
                                    rpm: dataUpdates.rpm !== undefined ? dataUpdates.rpm : data.rpm,
                                    speed: dataUpdates.speed !== undefined ? dataUpdates.speed : data.speed,
                                    coolant: dataUpdates.coolant !== undefined ? dataUpdates.coolant : data.coolant,
                                    enginePressure: dataUpdates.enginePressure !== undefined ? dataUpdates.enginePressure : data.enginePressure,
                                    batteryVoltage: dataUpdates.batteryVoltage !== undefined ? dataUpdates.batteryVoltage : data.batteryVoltage,
                                    ambientTemp: dataUpdates.ambientTemp !== undefined ? dataUpdates.ambientTemp : data.ambientTemp
                                }].slice(-100)); // Keep last 100 entries
                            }
                        }
                    }
                } catch (parseError) {
                    console.error('Error parsing data:', parseError);
                }
            };

            const handleDisconnection = () => {
                console.log('Device disconnected');
                setIsConnected(false);
                setDevice(null);
                setCharacteristic(null);
                
                // Log disconnection
                setRawDataLog(prev => [...prev, {
                    timestamp: new Date().toLocaleTimeString(),
                    data: 'Device disconnected',
                    type: 'disconnect'
                }]);
            };

            const disconnect = () => {
                if (device && device.gatt.connected) {
                    device.gatt.disconnect();
                }
            };

            // Function to send commands to device
            const sendCommand = (command) => {
                if (characteristic && device && device.gatt.connected) {
                    const message = `CMD:${command}`;
                    characteristic.writeValue(new TextEncoder().encode(message));
                    console.log('Sent command:', message);
                    
                    setRawDataLog(prev => [...prev, {
                        timestamp: new Date().toLocaleTimeString(),
                        data: 'TX: ' + message,
                        type: 'tx'
                    }]);
                }
            };

            // Function to toggle simulation
            const toggleSimulation = () => {
                if (data.simulationRunning) {
                    sendCommand('SIM_OFF');
                } else {
                    sendCommand('SIM_ON');
                }
            };

            // Periodic ping to keep connection alive
            useEffect(() => {
                if (isConnected) {
                    const pingInterval = setInterval(() => {
                        sendCommand('PING');
                    }, 30000); // Ping every 30 seconds

                    return () => clearInterval(pingInterval);
                }
            }, [isConnected]);

            // Helper function to get color class based on value and type
            const getColorClass = (value, type) => {
                switch (type) {
                    case 'rpm':
                        if (value > 6000) return 'danger';
                        if (value > 4000) return 'warning';
                        return 'normal';
                    case 'speed':
                        if (value > 80) return 'danger';
                        if (value > 60) return 'warning';
                        return 'normal';
                    case 'coolant':
                        if (value > 220) return 'danger';
                        if (value > 200) return 'warning';
                        return 'normal';
                    case 'pressure':
                        if (value < 10) return 'danger';
                        if (value < 20) return 'warning';
                        return 'normal';
                    case 'battery':
                        if (value < 11.5) return 'danger';
                        if (value < 12.0) return 'warning';
                        return 'normal';
                    case 'ambient':
                        if (value > 100) return 'danger';
                        if (value > 85) return 'warning';
                        return 'normal';
                    default:
                        return 'info';
                }
            };

            return (
                <div className="dashboard">

                    {error && (
                        <div className="error-message">
                            {error}
                        </div>
                    )}

                    {!navigator.bluetooth && (
                        <div className="error-message">
                            Web Bluetooth is not supported in this browser. Please use Chrome or Edge with HTTPS enabled.
                            <br />
                            <small>Note: Safari has limited Web Bluetooth support. For best results, use Chrome or Edge.</small>
                        </div>
                    )}

                    {navigator.bluetooth && location.protocol !== 'https:' && location.hostname !== 'localhost' && (
                        <div className="error-message">
                            Web Bluetooth requires HTTPS. Please serve this page over HTTPS or use localhost for testing.
                        </div>
                    )}

                    <div className="status-panel">
                        <h3>System Status
                            <div className="status" style={{display: 'inline-flex', alignItems: 'center', marginLeft: '20px'}}>
                                <div className={`status-indicator ${isConnected ? 'connected' : ''}`}></div>
                                <span style={{marginLeft: '8px', marginRight: '10px'}}>{isConnected ? 'Connected' : 'Disconnected'}</span>
                                <button
                                    className="connect-btn"
                                    onClick={isConnected ? disconnect : connectToDevice}
                                    disabled={!navigator.bluetooth}
                                    style={{marginRight: '10px'}}
                                >
                                    {isConnected ? 'Disconnect' : 'Connect to Freematics'}
                                </button>
                            </div>
                            <button 
                                className={`sim-control-btn ${data.simulationRunning ? 'stop' : ''}`}
                                onClick={toggleSimulation}
                                disabled={!isConnected}
                                title={data.simulationRunning ? 'Stop simulated data' : 'Start simulated data'}
                            >
                                {data.simulationRunning ? '‚èπ Stop Simulation' : '‚ñ∂ Start Simulation'}
                            </button>
                            <button 
                                style={{marginLeft: '10px', padding: '8px 16px', fontSize: '14px', backgroundColor: '#6c757d', color: 'white', border: 'none', borderRadius: '5px', cursor: isConnected ? 'pointer' : 'not-allowed'}}
                                onClick={() => sendCommand('STATUS')}
                                disabled={!isConnected}
                                title="Request current system status"
                            >
                                üîÑ Refresh Status
                            </button>
                        </h3>
                        <div>
                            <span className={`status-item ${data.dataMode.toLowerCase()}`}>
                                Data: {data.dataMode}
                            </span>
                            {Object.entries(data.systemStatus).map(([key, value]) => {
                                // Extract base status and indicator
                                const hasIndicator = value.includes('(') && value.includes(')');
                                const baseValue = hasIndicator ? value.split('(')[0] : value;
                                const indicator = hasIndicator ? value.match(/\(([^)]+)\)/)[1] : null;
                                
                                return (
                                    <span key={key} className={`status-item ${baseValue.toLowerCase()}`}>
                                        {key}: {baseValue}
                                        {indicator && (
                                            <small style={{fontSize: '0.7em', opacity: 0.8, marginLeft: '3px'}}>
                                                ({indicator})
                                            </small>
                                        )}
                                    </span>
                                );
                            })}
                        </div>
                        {data.lastError && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#f8d7da', color: '#721c24', borderRadius: '4px'}}>
                                <strong>Last Error:</strong> {data.lastError}
                            </div>
                        )}
                        {data.dataMode === 'DISABLED' && (
                            <div style={{marginTop: '10px', padding: '10px', backgroundColor: '#e2e3e5', color: '#6c757d', borderRadius: '4px'}}>
                                <strong>Info:</strong> Simulated data is disabled. Click "Start Simulation" to begin receiving test data.
                            </div>
                        )}
                        <div style={{marginTop: '10px', fontSize: '0.9em', color: '#6c757d'}}>
                            <strong>Controls:</strong> Use the buttons above to start/stop simulation or refresh system status. 
                            Simulation provides test data when no real vehicle is connected.
                        </div>
                    </div>

                    <div className="metrics-grid">
                        <div className="metric-card">
                            <div className="metric-label">Engine RPM</div>
                            <div className={`metric-value ${getColorClass(data.rpm, 'rpm')}`}>{data.rpm.toLocaleString()}</div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                            {data.dataMode === 'DISABLED' && <small style={{color: '#6c757d'}}>No Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Speed</div>
                            <div className={`metric-value ${getColorClass(data.speed, 'speed')}`}>{data.speed} <small>mph</small></div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Coolant Temp</div>
                            <div className={`metric-value ${getColorClass(data.coolant, 'coolant')}`}>{data.coolant}¬∞F</div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Engine Pressure</div>
                            <div className={`metric-value ${getColorClass(data.enginePressure, 'pressure')}`}>{data.enginePressure} <small>psi</small></div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Battery Voltage</div>
                            <div className={`metric-value ${getColorClass(data.batteryVoltage, 'battery')}`}>{data.batteryVoltage.toFixed(1)} <small>V</small></div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">Ambient Temp</div>
                            <div className={`metric-value ${getColorClass(data.ambientTemp, 'ambient')}`}>{data.ambientTemp}¬∞F</div>
                            {data.dataMode === 'SIMULATED' && <small style={{color: '#856404'}}>Simulated Data</small>}
                        </div>
                        <div className="metric-card">
                            <div className="metric-label">GPS Satellites</div>
                            <div className="metric-value info">
                                {data.gps.satellites}
                                {data.gps.satelliteIndicator && (
                                    <small style={{color: '#856404', display: 'block', fontSize: '0.4em', marginTop: '5px'}}>
                                        {data.gps.satelliteIndicator}
                                    </small>
                                )}
                            </div>
                        </div>
                    </div>

                    <div className="chart-container">
                        <div className="chart-wrapper">
                            <canvas ref={chartRef}></canvas>
                        </div>
                    </div>

                    <div className="gps-container">
                        <h3>GPS Location</h3>
                        <div className="gps-coords">
                            Latitude: {data.gps.lat.toFixed(6)}¬∞
                        </div>
                        <div className="gps-coords">
                            Longitude: {data.gps.lng.toFixed(6)}¬∞
                        </div>
                        <div className="gps-coords">
                            Satellites: {data.gps.satellites}
                            {data.gps.satelliteIndicator && (
                                <small style={{color: '#856404', marginLeft: '10px'}}>
                                    {data.gps.satelliteIndicator}
                                </small>
                            )}
                        </div>
                    </div>

                    <div className="data-log">
                        <h3>Raw Data Log 
                            <button 
                                style={{marginLeft: '10px', padding: '5px 10px', fontSize: '0.8em'}}
                                onClick={() => sendCommand('STATUS')}
                                disabled={!isConnected}
                            >
                                Request Status
                            </button>
                            <button 
                                style={{marginLeft: '5px', padding: '5px 10px', fontSize: '0.8em'}}
                                onClick={() => setRawDataLog([])}
                            >
                                Clear Log
                            </button>
                        </h3>
                        {rawDataLog.slice(-20).reverse().map((entry, index) => (
                            <div key={index} className={`log-entry ${entry.type || 'data'}`}>
                                <strong>{entry.timestamp}:</strong> {entry.data}
                            </div>
                        ))}
                        {rawDataLog.length === 0 && (
                            <div className="log-entry">No data received yet...</div>
                        )}
                        <div style={{marginTop: '10px', fontSize: '0.9em', color: '#6c757d'}}>
                            Total messages: {rawDataLog.length} | 
                            Connected: {isConnected ? 'Yes' : 'No'} |
                            API Version: {data.apiVersion !== null ? data.apiVersion : 'Unknown'} |
                            Last update: {rawDataLog.length > 0 ? rawDataLog[rawDataLog.length - 1].timestamp : 'Never'}
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FreematicsDashboard />, document.getElementById('root'));
    </script>
</body>
</html>
